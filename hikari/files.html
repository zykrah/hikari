<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.files API documentation</title>
<meta name="description" content="Utilities and classes for interacting with files and web resources.">
<meta property="og:title" content="hikari.files module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="index.html"
>hikari</a></li>
<li class="breadcrumb-item active"><a href="#">files</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Utilities and classes for interacting with files and web resources.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="LazyByteIteratorish -- Type hint representing an iterator/iterable of bytes …" href="#hikari.files.LazyByteIteratorish"
>LazyByteIteratorish</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Pathish -- Type hint representing a literal file or path …" href="#hikari.files.Pathish"
>Pathish</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Rawish -- Type hint representing valid raw data types …" href="#hikari.files.Rawish"
>Rawish</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Resourceish -- Type hint representing a file or path to a file/URL/data URI …" href="#hikari.files.Resourceish"
>Resourceish</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="ensure_path -- Convert a path-like object to a `pathlib.Path` instance." href="#hikari.files.ensure_path"
>ensure_path</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="ensure_resource -- Given a resource or string, convert it to a valid resource as needed …" href="#hikari.files.ensure_resource"
>ensure_resource</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="unwrap_bytes -- Convert a byte-like object to bytes." href="#hikari.files.unwrap_bytes"
>unwrap_bytes</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="data_uri -- Fetch the data URI …" href="#hikari.files.AsyncReader.data_uri"
>data_uri</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- The filename of the resource." href="#hikari.files.AsyncReader.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The mimetype of the resource. May be `builtins.None` if not known." href="#hikari.files.AsyncReader.mimetype"
>mimetype</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the rest of the resource and return it in a `builtins.bytes` object." href="#hikari.files.AsyncReader.read"
>read</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="AsyncReaderContextManager -- Context manager that returns a reader." href="#hikari.files.AsyncReaderContextManager"
>AsyncReaderContextManager</a>
<ul class="list-unstyled nested text-truncate">
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="Bytes -- Representation of in-memory data to upload …" href="#hikari.files.Bytes"
>Bytes</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="data -- The raw data/provider of raw data to upload." href="#hikari.files.Bytes.data"
>data</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"
>extension</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.Bytes.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="from_data_uri -- Parse a given data URI …" href="#hikari.files.Bytes.from_data_uri"
>from_data_uri</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_spoiler -- Whether the file will be marked as a spoiler." href="#hikari.files.Bytes.is_spoiler"
>is_spoiler</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The provided mimetype, if provided. Otherwise `builtins.None`." href="#hikari.files.Bytes.mimetype"
>mimetype</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="stream -- Start streaming the content in chunks …" href="#hikari.files.Bytes.stream"
>stream</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.Bytes.url"
>url</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="File -- A resource that exists on the local machine's storage to be uploaded …" href="#hikari.files.File"
>File</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"
>extension</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.File.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_spoiler -- Whether the file will be marked as a spoiler." href="#hikari.files.File.is_spoiler"
>is_spoiler</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="path -- The path to the file." href="#hikari.files.File.path"
>path</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="stream -- Start streaming the resource using a thread pool executor …" href="#hikari.files.File.stream"
>stream</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.File.url"
>url</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="FileReader -- Abstract base for a file reader object …" href="#hikari.files.FileReader"
>FileReader</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="data_uri -- Fetch the data URI …" href="#hikari.files.AsyncReader.data_uri"
>data_uri</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="executor -- The associated `concurrent.futures.Executor` to use for blocking IO." href="#hikari.files.FileReader.executor"
>executor</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- The filename of the resource." href="#hikari.files.FileReader.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The mimetype of the resource. May be `builtins.None` if not known." href="#hikari.files.FileReader.mimetype"
>mimetype</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="path -- The path to the resource to read." href="#hikari.files.FileReader.path"
>path</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the rest of the resource and return it in a `builtins.bytes` object." href="#hikari.files.AsyncReader.read"
>read</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IteratorReader -- Asynchronous file reader that operates on in-memory data …" href="#hikari.files.IteratorReader"
>IteratorReader</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="data -- The data that will be yielded in chunks." href="#hikari.files.IteratorReader.data"
>data</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="data_uri -- Fetch the data URI …" href="#hikari.files.AsyncReader.data_uri"
>data_uri</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- The filename of the resource." href="#hikari.files.IteratorReader.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The mimetype of the resource. May be `builtins.None` if not known." href="#hikari.files.IteratorReader.mimetype"
>mimetype</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the rest of the resource and return it in a `builtins.bytes` object." href="#hikari.files.AsyncReader.read"
>read</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"
>extension</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.Resource.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="stream -- Produce a stream of data for the resource …" href="#hikari.files.Resource.stream"
>stream</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.Resource.url"
>url</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="URL -- A URL that represents a web resource …" href="#hikari.files.URL"
>URL</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"
>extension</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.URL.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="stream -- Start streaming the content into memory by downloading it …" href="#hikari.files.WebResource.stream"
>stream</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.URL.url"
>url</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="WebReader -- Asynchronous reader to use to read data from a web resource …" href="#hikari.files.WebReader"
>WebReader</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="charset -- Optional character set information, if known." href="#hikari.files.WebReader.charset"
>charset</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="data_uri -- Fetch the data URI …" href="#hikari.files.AsyncReader.data_uri"
>data_uri</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- The filename of the resource." href="#hikari.files.WebReader.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="head_only -- If `builtins.True`, then only the HEAD was requested …" href="#hikari.files.WebReader.head_only"
>head_only</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The mimetype of the resource. May be `builtins.None` if not known." href="#hikari.files.WebReader.mimetype"
>mimetype</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the rest of the resource and return it in a `builtins.bytes` object." href="#hikari.files.WebReader.read"
>read</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="reason -- The HTTP response status reason." href="#hikari.files.WebReader.reason"
>reason</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="size -- The size of the resource, if known." href="#hikari.files.WebReader.size"
>size</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="status -- The initial HTTP response status." href="#hikari.files.WebReader.status"
>status</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="stream -- The `aiohttp.StreamReader` to read the content from." href="#hikari.files.WebReader.stream"
>stream</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- The URL being read from." href="#hikari.files.WebReader.url"
>url</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="WebResource -- Base class for a resource that resides on the internet …" href="#hikari.files.WebResource"
>WebResource</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"
>extension</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.Resource.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="stream -- Start streaming the content into memory by downloading it …" href="#hikari.files.WebResource.stream"
>stream</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.Resource.url"
>url</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L1-L1127" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Utilities and classes for interacting with files and web resources.&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.List[str] = [
    &#34;ensure_path&#34;,
    &#34;ensure_resource&#34;,
    &#34;unwrap_bytes&#34;,
    &#34;Pathish&#34;,
    &#34;Rawish&#34;,
    &#34;Resourceish&#34;,
    &#34;LazyByteIteratorish&#34;,
    &#34;AsyncReader&#34;,
    &#34;AsyncReaderContextManager&#34;,
    &#34;Resource&#34;,
    &#34;File&#34;,
    &#34;FileReader&#34;,
    &#34;WebResource&#34;,
    &#34;URL&#34;,
    &#34;WebReader&#34;,
    &#34;Bytes&#34;,
    &#34;IteratorReader&#34;,
]

import abc
import asyncio
import base64
import concurrent.futures
import inspect
import io
import mimetypes
import os
import pathlib
import typing
import urllib.parse
import urllib.request

import aiohttp.client
import attr

from hikari.internal import aio
from hikari.internal import net
from hikari.internal import time

if typing.TYPE_CHECKING:
    import types

_MAGIC: typing.Final[int] = 50 * 1024
SPOILER_TAG: typing.Final[str] = &#34;SPOILER_&#34;

ReaderImplT = typing.TypeVar(&#34;ReaderImplT&#34;, bound=&#34;AsyncReader&#34;)
ReaderImplT_co = typing.TypeVar(&#34;ReaderImplT_co&#34;, bound=&#34;AsyncReader&#34;, covariant=True)

Pathish = typing.Union[&#34;os.PathLike[str]&#34;, str]
&#34;&#34;&#34;Type hint representing a literal file or path.

This may be one of:

- `builtins.str` path.
- `os.PathLike` derivative, such as `pathlib.PurePath` and `pathlib.Path`.
&#34;&#34;&#34;

RAWISH_TYPES = (bytes, bytearray, memoryview, io.BytesIO, io.StringIO)

Rawish = typing.Union[bytes, bytearray, memoryview, io.BytesIO, io.StringIO]
&#34;&#34;&#34;Type hint representing valid raw data types.

This may be one of:

- `bytes`
- `bytearray`
- `memoryview`
- `io.BytesIO`
- `io.StringIO` (assuming UTF-8 encoding).
&#34;&#34;&#34;

LazyByteIteratorish = typing.Union[
    typing.AsyncIterator[bytes],
    typing.AsyncIterable[bytes],
    typing.Iterator[bytes],
    typing.Iterable[bytes],
    typing.AsyncIterator[str],
    typing.AsyncIterable[str],
    typing.Iterator[str],
    typing.Iterable[str],
    typing.AsyncGenerator[bytes, typing.Any],
    typing.Generator[bytes, typing.Any, typing.Any],
    typing.AsyncGenerator[str, typing.Any],
    typing.Generator[str, typing.Any, typing.Any],
    asyncio.StreamReader,
    aiohttp.StreamReader,
]
&#34;&#34;&#34;Type hint representing an iterator/iterable of bytes.

This may be one of:

- `typing.AsyncIterator[bytes]`
- `typing.AsyncIterable[bytes]`
- `typing.Iterator[bytes]`
- `typing.Iterable[bytes]`
- `typing.AsyncIterator[str]` (assuming UTF-8 encoding).
- `typing.AsyncIterable[str]` (assuming UTF-8 encoding).
- `typing.Iterator[str]` (assuming UTF-8 encoding).
- `typing.Iterable[str]` (assuming UTF-8 encoding).
- `asyncio.StreamReader`
- `aiohttp.StreamReader`
&#34;&#34;&#34;

Resourceish = typing.Union[&#34;Resource[typing.Any]&#34;, Pathish, Rawish]
&#34;&#34;&#34;Type hint representing a file or path to a file/URL/data URI.

This may be one of:

- `Resource` or a derivative.
- `builtins.str` path.
- `os.PathLike` derivative, such as `pathlib.PurePath` and `pathlib.Path`.
- `bytes`
- `bytearray`
- `memoryview`
- `io.BytesIO`
- `io.StringIO` (assuming UTF-8 encoding).
&#34;&#34;&#34;


def ensure_path(pathish: Pathish) -&gt; pathlib.Path:
    &#34;&#34;&#34;Convert a path-like object to a `pathlib.Path` instance.&#34;&#34;&#34;
    return pathlib.Path(pathish)


def unwrap_bytes(data: Rawish) -&gt; bytes:
    &#34;&#34;&#34;Convert a byte-like object to bytes.&#34;&#34;&#34;
    if isinstance(data, bytearray):
        data = bytes(data)
    elif isinstance(data, memoryview):
        data = data.tobytes()
    elif isinstance(data, io.StringIO):
        data = bytes(data.read(), &#34;utf-8&#34;)
    elif isinstance(data, io.BytesIO):
        data = data.read()

    return data


def ensure_resource(url_or_resource: Resourceish, /) -&gt; Resource[AsyncReader]:
    &#34;&#34;&#34;Given a resource or string, convert it to a valid resource as needed.

    Parameters
    ----------
    url_or_resource : Resourceish
        The item to convert. Ff a `Resource` is passed, it is
        simply returned again. Anything else is converted to a `Resource` first.

    Returns
    -------
    Resource
        The resource to use.
    &#34;&#34;&#34;
    if isinstance(url_or_resource, Resource):
        return url_or_resource

    if isinstance(url_or_resource, RAWISH_TYPES):
        data = unwrap_bytes(url_or_resource)
        filename = generate_filename_from_details(mimetype=None, extension=None, data=data)
        return typing.cast(&#34;Resource[AsyncReader]&#34;, Bytes(data, filename))

    url_or_resource = str(url_or_resource)

    if url_or_resource.startswith((&#34;https://&#34;, &#34;http://&#34;)):
        return typing.cast(&#34;Resource[AsyncReader]&#34;, URL(url_or_resource))
    if url_or_resource.startswith(&#34;data:&#34;):
        try:
            return typing.cast(&#34;Resource[AsyncReader]&#34;, Bytes.from_data_uri(url_or_resource))
        except ValueError:
            # If we cannot parse it, maybe it is some malformed file?
            pass

    path = pathlib.Path(url_or_resource)
    return typing.cast(&#34;Resource[AsyncReader]&#34;, File(path, path.name))


def guess_mimetype_from_filename(name: str, /) -&gt; typing.Optional[str]:
    &#34;&#34;&#34;Guess the mimetype of an object given a filename.

    Parameters
    ----------
    name : builtins.bytes
        The filename to inspect.

    Returns
    -------
    typing.Optional[builtins.str]
        The closest guess to the given filename. May be `builtins.None` if
        no match was found.
    &#34;&#34;&#34;
    guess, _ = mimetypes.guess_type(name)
    return guess


def guess_mimetype_from_data(data: bytes, /) -&gt; typing.Optional[str]:
    &#34;&#34;&#34;Guess the mimetype of some data from the header.

    !!! warning
        This function only detects valid image headers that Discord allows
        the use of. Anything else will go undetected.

    Parameters
    ----------
    data : builtins.bytes
        The byte content to inspect.

    Returns
    -------
    typing.Optional[builtins.str]
        The mimetype, if it was found. If the header is unrecognised, then
        `builtins.None` is returned.
    &#34;&#34;&#34;
    if data.startswith(b&#34;\211PNG\r\n\032\n&#34;):
        return &#34;image/png&#34;
    if data[6:].startswith((b&#34;Exif&#34;, b&#34;JFIF&#34;)):
        return &#34;image/jpeg&#34;
    if data.startswith((b&#34;GIF87a&#34;, b&#34;GIF89a&#34;)):
        return &#34;image/gif&#34;
    if data.startswith(b&#34;RIFF&#34;) and data[8:].startswith(b&#34;WEBP&#34;):
        return &#34;image/webp&#34;
    return None


def guess_file_extension(mimetype: str) -&gt; typing.Optional[str]:
    &#34;&#34;&#34;Guess the file extension for a given mimetype.

    Parameters
    ----------
    mimetype : builtins.str
        The mimetype to guess the extension for.

    Example
    -------
    ```py
    &gt;&gt;&gt; guess_file_extension(&#34;image/png&#34;)
    &#34;.png&#34;
    ```

    Returns
    -------
    typing.Optional[builtins.str]
        The file extension, prepended with a `.`. If no match was found,
        return `builtins.None`.
    &#34;&#34;&#34;
    return mimetypes.guess_extension(mimetype)


def generate_filename_from_details(
    *,
    mimetype: typing.Optional[str] = None,
    extension: typing.Optional[str] = None,
    data: typing.Optional[bytes] = None,
) -&gt; str:
    &#34;&#34;&#34;Given optional information about a resource, generate a filename.

    Parameters
    ----------
    mimetype : typing.Optional[builtins.str]
        The mimetype of the content, or `builtins.None` if not known.
    extension : typing.Optional[builtins.str]
        The file extension to use, or `builtins.None` if not known.
    data : typing.Optional[builtins.bytes]
        The data to inspect, or `builtins.None` if not known.

    Returns
    -------
    builtins.str
        A generated quasi-unique filename.
    &#34;&#34;&#34;
    if data is not None and mimetype is None:
        mimetype = guess_mimetype_from_data(data)

    if extension is None and mimetype is not None:
        extension = guess_file_extension(mimetype)

    if not extension:
        extension = &#34;&#34;
    elif not extension.startswith(&#34;.&#34;):
        extension = f&#34;.{extension}&#34;

    # Nanosecond precision will be less likely to collide.
    return time.uuid() + extension


def to_data_uri(data: bytes, mimetype: typing.Optional[str]) -&gt; str:
    &#34;&#34;&#34;Convert the data and mimetype to a data URI.

    Parameters
    ----------
    data : builtins.bytes
        The data to encode as base64.
    mimetype : typing.Optional[builtins.str]
        The mimetype, or `builtins.None` if we should attempt to guess it.

    Returns
    -------
    builtins.str
        A data URI string.
    &#34;&#34;&#34;
    if mimetype is None:
        mimetype = guess_mimetype_from_data(data)

        if mimetype is None:
            raise TypeError(&#34;Cannot infer mimetype from input data, specify it manually.&#34;)

    b64 = base64.b64encode(data).decode()
    return f&#34;data:{mimetype};base64,{b64}&#34;


@attr.define(weakref_slot=False)
class AsyncReader(typing.AsyncIterable[bytes], abc.ABC):
    &#34;&#34;&#34;Protocol for reading a resource asynchronously using bit inception.

    This supports being used as an async iterable, although the implementation
    detail is left to each implementation of this class to define.
    &#34;&#34;&#34;

    filename: str = attr.field(repr=True)
    &#34;&#34;&#34;The filename of the resource.&#34;&#34;&#34;

    mimetype: typing.Optional[str] = attr.field(repr=True)
    &#34;&#34;&#34;The mimetype of the resource. May be `builtins.None` if not known.&#34;&#34;&#34;

    async def data_uri(self) -&gt; str:
        &#34;&#34;&#34;Fetch the data URI.

        This reads the entire resource.
        &#34;&#34;&#34;
        return to_data_uri(await self.read(), self.mimetype)

    async def read(self) -&gt; bytes:
        &#34;&#34;&#34;Read the rest of the resource and return it in a `builtins.bytes` object.&#34;&#34;&#34;
        buff = bytearray()
        async for chunk in self:
            buff.extend(chunk)
        return buff


class AsyncReaderContextManager(abc.ABC, typing.Generic[ReaderImplT]):
    &#34;&#34;&#34;Context manager that returns a reader.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def __aenter__(self) -&gt; ReaderImplT:
        ...

    @abc.abstractmethod
    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        ...

    # These are only included at runtime in-order to avoid the model being typed as a synchronous context manager.
    if not typing.TYPE_CHECKING:

        def __enter__(self) -&gt; typing.NoReturn:
            # This is async only.
            cls = type(self)
            raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

        def __exit__(self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType) -&gt; None:
            return None


@attr.define(weakref_slot=False)
@typing.final
class _NoOpAsyncReaderContextManagerImpl(typing.Generic[ReaderImplT], AsyncReaderContextManager[ReaderImplT]):
    impl: ReaderImplT = attr.field()

    async def __aenter__(self) -&gt; ReaderImplT:
        return self.impl

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        pass


class Resource(typing.Generic[ReaderImplT], abc.ABC):
    &#34;&#34;&#34;Base for any uploadable or downloadable representation of information.

    These representations can be streamed using bit inception for performance,
    which may result in significant decrease in memory usage for larger
    resources.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @property
    @abc.abstractmethod
    def url(self) -&gt; str:
        &#34;&#34;&#34;URL of the resource.&#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def filename(self) -&gt; str:
        &#34;&#34;&#34;Filename of the resource.&#34;&#34;&#34;

    @property
    def extension(self) -&gt; typing.Optional[str]:
        &#34;&#34;&#34;File extension, if there is one.&#34;&#34;&#34;
        _, _, ext = self.filename.rpartition(&#34;.&#34;)
        return ext if ext != self.filename else None

    async def read(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;Read the entire resource at once into memory.

        ```py
        data = await resource.read(...)
        # ^-- This is a shortcut for the following --v
        async with resource.stream(...) as reader:
            data = await reader.read()
        ```

        !!! warning
            If you simply wish to re-upload this resource to Discord via
            any endpoint in Hikari, you should opt to just pass this
            resource object directly. This way, Hikari can perform byte
            inception, which significantly reduces the memory usage for
            your bot as it grows larger.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            The executor to run in for blocking operations.
            If `builtins.None`, then the default executor is used for the
            current event loop.

        Returns
        -------
        builtins.bytes
            The entire resource.
        &#34;&#34;&#34;
        async with self.stream(executor=executor) as reader:
            return await reader.read()

    @abc.abstractmethod
    def stream(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        head_only: bool = False,
    ) -&gt; AsyncReaderContextManager[ReaderImplT]:
        &#34;&#34;&#34;Produce a stream of data for the resource.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            The executor to run in for blocking operations.
            If `builtins.None`, then the default executor is used for the
            current event loop.
        head_only : builtins.bool
            Defaults to `builtins.False`. If `builtins.True`, then the
            implementation may only retrieve HEAD information if supported.
            This currently only has any effect for web requests. This will
            fetch the headers for the HTTP resource this object points to
            without downloading the entire content, which can be significantly
            faster if you are scanning file types in messages, for example.

        Returns
        -------
        AsyncReaderContextManager[AsyncReader]
            An async iterable of bytes to stream.
        &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return self.url

    def __repr__(self) -&gt; str:
        return f&#34;{type(self).__name__}(url={self.url!r}, filename={self.filename!r})&#34;

    def __eq__(self, other: typing.Any) -&gt; bool:
        if isinstance(other, Resource):
            return self.url == other.url
        return False

    def __hash__(self) -&gt; int:
        return hash((self.__class__, self.url))


###################
# WEBSITE STREAMS #
###################


@attr.define(weakref_slot=False)
class WebReader(AsyncReader):
    &#34;&#34;&#34;Asynchronous reader to use to read data from a web resource.&#34;&#34;&#34;

    stream: aiohttp.StreamReader = attr.field(repr=False)
    &#34;&#34;&#34;The `aiohttp.StreamReader` to read the content from.&#34;&#34;&#34;

    url: str = attr.field(repr=False)
    &#34;&#34;&#34;The URL being read from.&#34;&#34;&#34;

    status: int = attr.field()
    &#34;&#34;&#34;The initial HTTP response status.&#34;&#34;&#34;

    reason: str = attr.field()
    &#34;&#34;&#34;The HTTP response status reason.&#34;&#34;&#34;

    charset: typing.Optional[str] = attr.field()
    &#34;&#34;&#34;Optional character set information, if known.&#34;&#34;&#34;

    size: typing.Optional[int] = attr.field()
    &#34;&#34;&#34;The size of the resource, if known.&#34;&#34;&#34;

    head_only: bool = attr.field()
    &#34;&#34;&#34;If `builtins.True`, then only the HEAD was requested.

    In this case, neither `__aiter__` nor `read` would return anything other
    than an empty byte string.
    &#34;&#34;&#34;

    async def read(self) -&gt; bytes:
        return b&#34;&#34; if self.head_only else await self.stream.read()

    async def __aiter__(self) -&gt; typing.AsyncGenerator[typing.Any, bytes]:
        if self.head_only:
            yield b&#34;&#34;
        else:
            while not self.stream.at_eof():
                chunk, _ = await self.stream.readchunk()
                yield chunk


@typing.final
class _WebReaderAsyncReaderContextManagerImpl(AsyncReaderContextManager[WebReader]):
    __slots__: typing.Sequence[str] = (&#34;_web_resource&#34;, &#34;_head_only&#34;, &#34;_client_response_ctx&#34;, &#34;_client_session&#34;)

    def __init__(self, web_resource: WebResource, head_only: bool) -&gt; None:
        self._web_resource = web_resource
        self._head_only = head_only
        self._client_session: aiohttp.ClientSession = NotImplemented
        self._client_response_ctx: typing.AsyncContextManager[aiohttp.client.ClientResponse] = NotImplemented

    async def __aenter__(self) -&gt; WebReader:
        client_session = aiohttp.ClientSession()

        method = &#34;HEAD&#34; if self._head_only else &#34;GET&#34;

        ctx = client_session.request(method, self._web_resource.url, raise_for_status=False)

        try:
            resp: aiohttp.ClientResponse = await ctx.__aenter__()

            if 200 &lt;= resp.status &lt; 400:
                mimetype = None
                filename = self._web_resource.filename

                if resp.content_disposition is not None:
                    mimetype = resp.content_disposition.type

                if mimetype is None:
                    mimetype = resp.content_type

                self._client_response_ctx = ctx
                self._client_session = client_session

                return WebReader(
                    stream=resp.content,
                    url=str(resp.real_url),
                    status=resp.status,
                    reason=str(resp.reason),
                    filename=filename,
                    charset=resp.charset,
                    mimetype=mimetype,
                    size=resp.content_length,
                    head_only=self._head_only,
                )
            else:
                raise await net.generate_error_response(resp)

        except Exception as ex:
            await ctx.__aexit__(type(ex), ex, ex.__traceback__)
            await client_session.close()
            raise

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        await self._client_response_ctx.__aexit__(exc_type, exc, exc_tb)
        await self._client_session.close()


class WebResource(Resource[WebReader], abc.ABC):
    &#34;&#34;&#34;Base class for a resource that resides on the internet.

    The logic for identifying this resource is left to each implementation
    to define.

    !!! info
        For a usable concrete implementation, use `URL` instead.

    !!! note
        Some components may choose to not upload this resource directly and
        instead simply refer to the URL as needed. The main place this will
        occur is within embeds.

        If you need to re-upload the resource, you should download it into
        a `builtins.bytes` and pass that instead in these cases.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def stream(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        head_only: bool = False,
    ) -&gt; AsyncReaderContextManager[WebReader]:
        &#34;&#34;&#34;Start streaming the content into memory by downloading it.

        You can use this to fetch the entire resource, parts of the resource,
        or just to view any metadata that may be provided.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            Not used. Provided only to match the underlying interface.
        head_only : builtins.bool
            Defaults to `builtins.False`. If `builtins.True`, then the
            implementation may only retrieve HEAD information if supported.
            This currently only has any effect for web requests.

        Examples
        --------
        Downloading an entire resource at once into memory:
        ```py
        async with obj.stream() as stream:
            data = await stream.read()
        ```
        Checking the metadata:
        ```py
        async with obj.stream() as stream:
            mimetype = stream.mimetype

        if mimetype is None:
            ...
        elif mimetype not in whitelisted_mimetypes:
            ...
        else:
            ...
        ```
        Fetching the data-uri of a resource:
        ```py
        async with obj.stream() as stream:
            data_uri = await stream.data_uri()
        ```

        Returns
        -------
        AsyncReaderContextManager[WebReader]
            An async context manager that when entered, produces the
            data stream.

        Raises
        ------
        hikari.errors.BadRequestError
            If a 400 is returned.
        hikari.errors.UnauthorizedError
            If a 401 is returned.
        hikari.errors.ForbiddenError
            If a 403 is returned.
        hikari.errors.NotFoundError
            If a 404 is returned.
        hikari.errors.ClientHTTPResponseError
            If any other 4xx is returned.
        hikari.errors.InternalServerError
            If any other 5xx is returned.
        hikari.errors.HTTPResponseError
            If any other unexpected response code is returned.
        &#34;&#34;&#34;
        return _WebReaderAsyncReaderContextManagerImpl(self, head_only)


@typing.final
class URL(WebResource):
    &#34;&#34;&#34;A URL that represents a web resource.

    Parameters
    ----------
    url : builtins.str
        The URL of the resource.

    !!! note
        Some components may choose to not upload this resource directly and
        instead simply refer to the URL as needed. The main place this will
        occur is within embeds.

        If you need to re-upload the resource, you should download it into
        a `builtins.bytes` and pass that instead in these cases.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_url&#34;,)

    def __init__(self, url: str) -&gt; None:
        self._url = url

    @property
    def url(self) -&gt; str:
        return self._url

    @property
    def filename(self) -&gt; str:
        url = urllib.parse.urlparse(self._url)
        return os.path.basename(url.path)


########################################
# ON-DISK FILESYSTEM RESOURCE READERS. #
########################################


@attr.define(weakref_slot=False)
class FileReader(AsyncReader, abc.ABC):
    &#34;&#34;&#34;Abstract base for a file reader object.

    Various implementations have to exist in order to cater for situations
    where we cannot pass IO objects around (e.g. ProcessPoolExecutors, since
    they pickle things).
    &#34;&#34;&#34;

    executor: typing.Optional[concurrent.futures.Executor] = attr.field()
    &#34;&#34;&#34;The associated `concurrent.futures.Executor` to use for blocking IO.&#34;&#34;&#34;

    path: pathlib.Path = attr.field(converter=ensure_path)
    &#34;&#34;&#34;The path to the resource to read.&#34;&#34;&#34;


@attr.define(weakref_slot=False)
class ThreadedFileReader(FileReader):
    &#34;&#34;&#34;Asynchronous file reader that reads a resource from local storage.

    This implementation works with pools that exist in the same interpreter
    instance as the caller, namely thread pool executors, where objects
    do not need to be pickled to be communicated.
    &#34;&#34;&#34;

    async def __aiter__(self) -&gt; typing.AsyncGenerator[typing.Any, bytes]:
        loop = asyncio.get_running_loop()

        path = self.path
        if isinstance(path, pathlib.Path):
            path = await loop.run_in_executor(self.executor, self._expand, self.path)

        fp = await loop.run_in_executor(self.executor, self._open, path)

        try:
            while True:
                chunk = await loop.run_in_executor(self.executor, self._read_chunk, fp, _MAGIC)
                yield chunk
                if len(chunk) &lt; _MAGIC:
                    break

        finally:
            await loop.run_in_executor(self.executor, self._close, fp)

    @staticmethod
    def _expand(path: pathlib.Path) -&gt; pathlib.Path:
        # .expanduser is Platform dependent. Will expand stuff like ~ to /home/&lt;user&gt; on posix.
        # .resolve will follow symlinks and what-have-we to translate stuff like `..` to proper paths.
        return path.expanduser().resolve()

    @staticmethod
    @typing.final
    def _read_chunk(fp: typing.IO[bytes], n: int = 10_000) -&gt; bytes:
        return fp.read(n)

    @staticmethod
    def _open(path: Pathish) -&gt; typing.IO[bytes]:
        return open(path, &#34;rb&#34;)

    @staticmethod
    def _close(fp: typing.IO[bytes]) -&gt; None:
        fp.close()


@attr.define(slots=False, weakref_slot=False)  # Do not slot (pickle)
class MultiprocessingFileReader(FileReader):
    &#34;&#34;&#34;Asynchronous file reader that reads a resource from local storage.

    This implementation works with pools that exist in a different interpreter
    instance to the caller. Currently this only includes ProcessPoolExecutors
    and custom implementations where objects have to be pickled to be used
    by the pool.
    &#34;&#34;&#34;

    async def __aiter__(self) -&gt; typing.AsyncGenerator[typing.Any, bytes]:
        yield await asyncio.get_running_loop().run_in_executor(self.executor, self._read_all)

    def __getstate__(self) -&gt; typing.Dict[str, typing.Any]:
        return {&#34;path&#34;: self.path, &#34;filename&#34;: self.filename}

    def __setstate__(self, state: typing.Dict[str, typing.Any]) -&gt; None:
        self.path = state[&#34;path&#34;]
        self.filename = state[&#34;filename&#34;]
        self.executor = None
        self.mimetype = None

    def _read_all(self) -&gt; bytes:
        with open(self.path, &#34;rb&#34;) as fp:
            return fp.read()


class File(Resource[FileReader]):
    &#34;&#34;&#34;A resource that exists on the local machine&#39;s storage to be uploaded.

    Parameters
    ----------
    path : typing.Union[builtins.str, os.PathLike, pathlib.Path]
        The path to use.

        !!! note
            If passing a `pathlib.Path`, this must not be a `pathlib.PurePath`
            directly, as it will be used to expand tokens such as `~` that
            denote the home directory, and `..` for relative paths.

            This will all be performed as required in an executor to prevent
            blocking the event loop.
    filename : typing.Optional[builtins.str]
        The filename to use. If this is `builtins.None`, the name of the file is taken
        from the path instead.
    spoiler : bool
        Whether to mark the file as a spoiler in Discord. Defaults to `builtins.False`.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;path&#34;, &#34;_filename&#34;, &#34;is_spoiler&#34;)

    path: pathlib.Path
    &#34;&#34;&#34;The path to the file.&#34;&#34;&#34;

    is_spoiler: bool
    &#34;&#34;&#34;Whether the file will be marked as a spoiler.&#34;&#34;&#34;

    _filename: typing.Optional[str]

    def __init__(self, path: Pathish, /, filename: typing.Optional[str] = None, *, spoiler: bool = False) -&gt; None:
        self.path = ensure_path(path)
        self.is_spoiler = spoiler
        self._filename = filename

    @property
    @typing.final
    def url(self) -&gt; str:
        return f&#34;attachment://{self.filename}&#34;

    @property
    def filename(self) -&gt; str:
        filename = self._filename if self._filename else self.path.name

        if self.is_spoiler:
            return SPOILER_TAG + filename

        return filename

    def stream(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        head_only: bool = False,
    ) -&gt; AsyncReaderContextManager[FileReader]:
        &#34;&#34;&#34;Start streaming the resource using a thread pool executor.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            The executor to run the blocking read operations in. If
            `builtins.None`, the default executor for the running event loop
            will be used instead.
        head_only : builtins.bool
            Not used. Provided only to match the underlying interface.

        Returns
        -------
        AsyncReaderContextManager[FileReader]
            An async context manager that when entered, produces the
            data stream.
        &#34;&#34;&#34;
        # asyncio forces the default executor when this is None to always be a thread pool executor anyway,
        # so this is safe enough to do.:
        is_threaded = executor is None or isinstance(executor, concurrent.futures.ThreadPoolExecutor)
        impl = ThreadedFileReader if is_threaded else MultiprocessingFileReader
        return _NoOpAsyncReaderContextManagerImpl(impl(self.filename, None, executor, self.path))


########################################################################
# RAW BYTE, ASYNC ITERATOR, ASYNC ITERABLE, ITERATOR, ITERABLE READERS #
########################################################################


@attr.define(weakref_slot=False)
class IteratorReader(AsyncReader):
    &#34;&#34;&#34;Asynchronous file reader that operates on in-memory data.&#34;&#34;&#34;

    data: typing.Union[bytes, LazyByteIteratorish] = attr.field()
    &#34;&#34;&#34;The data that will be yielded in chunks.&#34;&#34;&#34;

    async def __aiter__(self) -&gt; typing.AsyncGenerator[typing.Any, bytes]:
        buff = bytearray()
        iterator = self._wrap_iter()

        while True:
            try:
                while len(buff) &lt; _MAGIC:
                    chunk = await iterator.__anext__()
                    buff.extend(chunk)
                yield bytes(buff)
                buff.clear()
            except StopAsyncIteration:
                break

        if buff:
            yield bytes(buff)

    async def _wrap_iter(self) -&gt; typing.AsyncGenerator[typing.Any, bytes]:
        if isinstance(self.data, bytes):
            for i in range(0, len(self.data), _MAGIC):
                yield self.data[i : i + _MAGIC]  # noqa: E203 - Whitespace before &#34;:&#34;

        elif aio.is_async_iterator(self.data) or inspect.isasyncgen(self.data):
            try:
                while True:
                    yield self._assert_bytes(await self.data.__anext__())  # type: ignore[union-attr]
            except StopAsyncIteration:
                pass

        elif isinstance(self.data, typing.Iterator):
            try:
                while True:
                    yield self._assert_bytes(next(self.data))
            except StopIteration:
                pass

        elif inspect.isgenerator(self.data):
            try:
                while True:
                    yield self._assert_bytes(self.data.send(None))  # type: ignore[union-attr]
            except StopIteration:
                pass

        elif aio.is_async_iterable(self.data):
            async for chunk in self.data:
                yield self._assert_bytes(chunk)

        elif isinstance(self.data, typing.Iterable):
            for chunk in self.data:
                yield self._assert_bytes(chunk)

        else:
            # Will always fail.
            self._assert_bytes(self.data)

    @staticmethod
    def _assert_bytes(data: typing.Any) -&gt; bytes:
        if isinstance(data, str):
            return bytes(data, &#34;utf-8&#34;)

        if not isinstance(data, bytes):
            raise TypeError(f&#34;Expected bytes but received {type(data).__name__}&#34;)
        return data


class Bytes(Resource[IteratorReader]):
    &#34;&#34;&#34;Representation of in-memory data to upload.

    Parameters
    ----------
    data : typing.Union[Rawish, LazyByteIteratorish]
        The raw data.
    filename : builtins.str
        The filename to use.
    mimetype : typing.Optional[builtins.str]
        The mimetype, or `builtins.None` if you do not wish to specify this.
        If not provided, then this will be generated from the file extension
        of the filename instead.
    spoiler : bool
        Whether to mark the file as a spoiler in Discord. Defaults to `builtins.False`.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;data&#34;, &#34;_filename&#34;, &#34;mimetype&#34;, &#34;is_spoiler&#34;)

    data: typing.Union[bytes, LazyByteIteratorish]
    &#34;&#34;&#34;The raw data/provider of raw data to upload.&#34;&#34;&#34;

    mimetype: typing.Optional[str]
    &#34;&#34;&#34;The provided mimetype, if provided. Otherwise `builtins.None`.&#34;&#34;&#34;

    is_spoiler: bool
    &#34;&#34;&#34;Whether the file will be marked as a spoiler.&#34;&#34;&#34;

    def __init__(
        self,
        data: typing.Union[Rawish, LazyByteIteratorish],
        filename: str,
        /,
        mimetype: typing.Optional[str] = None,
        *,
        spoiler: bool = False,
    ) -&gt; None:
        if isinstance(data, RAWISH_TYPES):
            data = unwrap_bytes(data)

        self.data = data

        if mimetype is None:
            mimetype = guess_mimetype_from_filename(filename)

        if mimetype is None:
            mimetype = &#34;text/plain;charset=UTF-8&#34;

        self._filename = filename
        self.mimetype = mimetype
        self.is_spoiler = spoiler

    @property
    def url(self) -&gt; str:
        return f&#34;attachment://{self.filename}&#34;

    @property
    def filename(self) -&gt; str:
        if self.is_spoiler:
            return SPOILER_TAG + self._filename

        return self._filename

    def stream(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        head_only: bool = False,
    ) -&gt; AsyncReaderContextManager[IteratorReader]:
        &#34;&#34;&#34;Start streaming the content in chunks.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            Not used. Provided only to match the underlying interface.
        head_only : builtins.bool
            Not used. Provided only to match the underlying interface.

        Returns
        -------
        AsyncReaderContextManager[IteratorReader]
            An async context manager that when entered, produces the
            data stream.
        &#34;&#34;&#34;
        return _NoOpAsyncReaderContextManagerImpl(IteratorReader(self.filename, self.mimetype, self.data))

    @staticmethod
    def from_data_uri(data_uri: str, filename: typing.Optional[str] = None) -&gt; Bytes:
        &#34;&#34;&#34;Parse a given data URI.

        Parameters
        ----------
        data_uri : builtins.str
            The data URI to parse.
        filename : typing.Optional[builtins.str]
            Filename to use. If this is not provided, then this is generated
            instead.

        Returns
        -------
        Bytes
            The parsed data URI as a `Bytes` object.

        Raises
        ------
        builtins.ValueError
            If the parsed argument is not a data URI.
        &#34;&#34;&#34;
        if not data_uri.startswith(&#34;data:&#34;):
            raise ValueError(&#34;Invalid data URI passed&#34;)

        # This will not block for a data URI; if it was a URL, it would block, so
        # we guard against this with the check above.
        try:
            with urllib.request.urlopen(data_uri) as response:  # noqa: S310   audit url open for permitted schemes
                mimetype, _ = mimetypes.guess_type(data_uri)
                data = response.read()
        except Exception as ex:
            raise ValueError(&#34;Failed to decode data URI&#34;) from ex

        if filename is None:
            filename = generate_filename_from_details(mimetype=mimetype, data=data)

        return Bytes(data, filename, mimetype=mimetype)</code></pre>
</details>
</div>
</div>
<h2 id="variables-heading">Variables and Type Hints</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.files.LazyByteIteratorish" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="LazyByteIteratorish -- Type hint representing an iterator/iterable of bytes …" href="#hikari.files.LazyByteIteratorish"  >LazyByteIteratorish</a> = typing.Union[typing.AsyncIterator[bytes], typing.AsyncIterable[bytes], typing.Iterator[bytes], typing.Iterable[bytes], typing.AsyncIterator[str], typing.AsyncIterable[str], typing.Iterator[str], typing.Iterable[str], typing.AsyncGenerator[bytes, typing.Any], typing.Generator[bytes, typing.Any, typing.Any], typing.AsyncGenerator[str, typing.Any], typing.Generator[str, typing.Any, typing.Any], asyncio.streams.StreamReader, aiohttp.streams.StreamReader]</code></pre>
</dt>
<dd><p>Type hint representing an iterator/iterable of bytes.</p>
<p>This may be one of:</p>
<ul>
<li><code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a>[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>]</code></li>
<li><code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterable'>AsyncIterable</a>[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>]</code></li>
<li><code><a href='https://docs.python.org/3/library/typing.html#typing.Iterator'>Iterator</a>[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>]</code></li>
<li><code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>]</code></li>
<li><code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code> (assuming UTF-8 encoding).</li>
<li><code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterable'>AsyncIterable</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code> (assuming UTF-8 encoding).</li>
<li><code><a href='https://docs.python.org/3/library/typing.html#typing.Iterator'>Iterator</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code> (assuming UTF-8 encoding).</li>
<li><code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code> (assuming UTF-8 encoding).</li>
<li><code><a href='https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader'>StreamReader</a></code></li>
<li><code><a href='https://docs.aiohttp.org/en/stable/streams.html#aiohttp.StreamReader'>aiohttp.StreamReader</a></code></li>
</ul></dd>
</div>
<div id="hikari.files.Pathish" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Pathish -- Type hint representing a literal file or path …" href="#hikari.files.Pathish"  >Pathish</a> = typing.Union[ForwardRef('os.PathLike[str]'), str]</code></pre>
</dt>
<dd><p>Type hint representing a literal file or path.</p>
<p>This may be one of:</p>
<ul>
<li><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> path.</li>
<li><code><a href='https://docs.python.org/3/library/os.html#os.PathLike'>os.PathLike</a></code> derivative, such as <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> and <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.Path'>pathlib.Path</a></code>.</li>
</ul></dd>
</div>
<div id="hikari.files.Rawish" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Rawish -- Type hint representing valid raw data types …" href="#hikari.files.Rawish"  >Rawish</a> = typing.Union[bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO]</code></pre>
</dt>
<dd><p>Type hint representing valid raw data types.</p>
<p>This may be one of:</p>
<ul>
<li><code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></li>
<li><code><a href='https://docs.python.org/3/library/stdtypes.html#bytearray'>bytearray</a></code></li>
<li><code><a href='https://docs.python.org/3/library/stdtypes.html#memoryview'>memoryview</a></code></li>
<li><code><a href='https://docs.python.org/3/library/io.html#io.BytesIO'>io.BytesIO</a></code></li>
<li><code><a href='https://docs.python.org/3/library/io.html#io.StringIO'>io.StringIO</a></code> (assuming UTF-8 encoding).</li>
</ul></dd>
</div>
<div id="hikari.files.Resourceish" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Resourceish -- Type hint representing a file or path to a file/URL/data URI …" href="#hikari.files.Resourceish"  >Resourceish</a> = typing.Union[ForwardRef('Resource[typing.Any]'), ForwardRef('os.PathLike[str]'), str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO]</code></pre>
</dt>
<dd><p>Type hint representing a file or path to a file/URL/data URI.</p>
<p>This may be one of:</p>
<ul>
<li><code><a href='#hikari.files.Resource'>Resource</a></code> or a derivative.</li>
<li><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> path.</li>
<li><code><a href='https://docs.python.org/3/library/os.html#os.PathLike'>os.PathLike</a></code> derivative, such as <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> and <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.Path'>pathlib.Path</a></code>.</li>
<li><code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></li>
<li><code><a href='https://docs.python.org/3/library/stdtypes.html#bytearray'>bytearray</a></code></li>
<li><code><a href='https://docs.python.org/3/library/stdtypes.html#memoryview'>memoryview</a></code></li>
<li><code><a href='https://docs.python.org/3/library/io.html#io.BytesIO'>io.BytesIO</a></code></li>
<li><code><a href='https://docs.python.org/3/library/io.html#io.StringIO'>io.StringIO</a></code> (assuming UTF-8 encoding).</li>
</ul></dd>
</div>
</dl>
</section>
<h2 id="functions-heading">Functions</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.files.ensure_path" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="ensure_path" href="#hikari.files.ensure_path" id="hikari.files.ensure_path">ensure_path</a>(
    pathish: <a href='#hikari.files.Pathish'>Pathish</a>,
) -> <a href='https://docs.python.org/3/library/pathlib.html#pathlib.Path'>pathlib.Path</a>: ...</code></pre>
</dt>
<dd>
<p>Convert a path-like object to a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.Path'>pathlib.Path</a></code> instance.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L147-L149" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def ensure_path(pathish: Pathish) -&gt; pathlib.Path:
    &#34;&#34;&#34;Convert a path-like object to a `pathlib.Path` instance.&#34;&#34;&#34;
    return pathlib.Path(pathish)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.ensure_resource" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="ensure_resource" href="#hikari.files.ensure_resource" id="hikari.files.ensure_resource">ensure_resource</a>(
    url_or_resource: <a href='#hikari.files.Resourceish'>Resourceish</a>,
    /,
) -> <a href='#hikari.files.Resource'>Resource</a>[<a href='#hikari.files.AsyncReader'>AsyncReader</a>]: ...</code></pre>
</dt>
<dd>
<p>Given a resource or string, convert it to a valid resource as needed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url_or_resource</code></strong> :&ensp;<code><a href='#hikari.files.Resourceish'>Resourceish</a></code></dt>
<dd>The item to convert. Ff a <code><a href='#hikari.files.Resource'>Resource</a></code> is passed, it is
simply returned again. Anything else is converted to a <code><a href='#hikari.files.Resource'>Resource</a></code> first.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.files.Resource'>Resource</a></code></dt>
<dd>The resource to use.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L166-L200" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def ensure_resource(url_or_resource: Resourceish, /) -&gt; Resource[AsyncReader]:
    &#34;&#34;&#34;Given a resource or string, convert it to a valid resource as needed.

    Parameters
    ----------
    url_or_resource : Resourceish
        The item to convert. Ff a `Resource` is passed, it is
        simply returned again. Anything else is converted to a `Resource` first.

    Returns
    -------
    Resource
        The resource to use.
    &#34;&#34;&#34;
    if isinstance(url_or_resource, Resource):
        return url_or_resource

    if isinstance(url_or_resource, RAWISH_TYPES):
        data = unwrap_bytes(url_or_resource)
        filename = generate_filename_from_details(mimetype=None, extension=None, data=data)
        return typing.cast(&#34;Resource[AsyncReader]&#34;, Bytes(data, filename))

    url_or_resource = str(url_or_resource)

    if url_or_resource.startswith((&#34;https://&#34;, &#34;http://&#34;)):
        return typing.cast(&#34;Resource[AsyncReader]&#34;, URL(url_or_resource))
    if url_or_resource.startswith(&#34;data:&#34;):
        try:
            return typing.cast(&#34;Resource[AsyncReader]&#34;, Bytes.from_data_uri(url_or_resource))
        except ValueError:
            # If we cannot parse it, maybe it is some malformed file?
            pass

    path = pathlib.Path(url_or_resource)
    return typing.cast(&#34;Resource[AsyncReader]&#34;, File(path, path.name))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.unwrap_bytes" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="unwrap_bytes" href="#hikari.files.unwrap_bytes" id="hikari.files.unwrap_bytes">unwrap_bytes</a>(
    data: <a href='#hikari.files.Rawish'>Rawish</a>,
) -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p>Convert a byte-like object to bytes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L152-L163" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def unwrap_bytes(data: Rawish) -&gt; bytes:
    &#34;&#34;&#34;Convert a byte-like object to bytes.&#34;&#34;&#34;
    if isinstance(data, bytearray):
        data = bytes(data)
    elif isinstance(data, memoryview):
        data = data.tobytes()
    elif isinstance(data, io.StringIO):
        data = bytes(data.read(), &#34;utf-8&#34;)
    elif isinstance(data, io.BytesIO):
        data = data.read()

    return data</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
</section>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.files.AsyncReader" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.AsyncReader" class="hljs python"><abbr title='A standard Python type.'>class</abbr> AsyncReader (
    filename: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    mimetype: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
): ...</code></pre>
<p>Protocol for reading a resource asynchronously using bit inception.</p>
<p>This supports being used as an async iterable, although the implementation
detail is left to each implementation of this class to define.</p>
<p>Method generated by attrs for class AsyncReader.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L337-L362" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class AsyncReader(typing.AsyncIterable[bytes], abc.ABC):
    &#34;&#34;&#34;Protocol for reading a resource asynchronously using bit inception.

    This supports being used as an async iterable, although the implementation
    detail is left to each implementation of this class to define.
    &#34;&#34;&#34;

    filename: str = attr.field(repr=True)
    &#34;&#34;&#34;The filename of the resource.&#34;&#34;&#34;

    mimetype: typing.Optional[str] = attr.field(repr=True)
    &#34;&#34;&#34;The mimetype of the resource. May be `builtins.None` if not known.&#34;&#34;&#34;

    async def data_uri(self) -&gt; str:
        &#34;&#34;&#34;Fetch the data URI.

        This reads the entire resource.
        &#34;&#34;&#34;
        return to_data_uri(await self.read(), self.mimetype)

    async def read(self) -&gt; bytes:
        &#34;&#34;&#34;Read the rest of the resource and return it in a `builtins.bytes` object.&#34;&#34;&#34;
        buff = bytearray()
        async for chunk in self:
            buff.extend(chunk)
        return buff</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="FileReader -- Abstract base for a file reader object …" href="#hikari.files.FileReader"
>FileReader</a></dt>
<dd class="nested"><p>Abstract base for a file reader object …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IteratorReader -- Asynchronous file reader that operates on in-memory data …" href="#hikari.files.IteratorReader"
>IteratorReader</a></dt>
<dd class="nested"><p>Asynchronous file reader that operates on in-memory data …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="WebReader -- Asynchronous reader to use to read data from a web resource …" href="#hikari.files.WebReader"
>WebReader</a></dt>
<dd class="nested"><p>Asynchronous reader to use to read data from a web resource …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="collections.abc.AsyncIterable -- " href="https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncIterable"
>collections.abc.AsyncIterable</a></dt>
<dd class="nested"></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.AsyncReader.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- The filename of the resource." href="#hikari.files.AsyncReader.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The filename of the resource.</p></dd>
</div>
<div id="hikari.files.AsyncReader.mimetype" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The mimetype of the resource. May be `builtins.None` if not known." href="#hikari.files.AsyncReader.mimetype"  >mimetype</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The mimetype of the resource. May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if not known.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.AsyncReader.data_uri" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="data_uri" href="#hikari.files.AsyncReader.data_uri" id="hikari.files.AsyncReader.data_uri">data_uri</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch the data URI.</p>
<p>This reads the entire resource.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L350-L355" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def data_uri(self) -&gt; str:
    &#34;&#34;&#34;Fetch the data URI.

    This reads the entire resource.
    &#34;&#34;&#34;
    return to_data_uri(await self.read(), self.mimetype)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.AsyncReader.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.AsyncReader.read" id="hikari.files.AsyncReader.read">read</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p>Read the rest of the resource and return it in a <code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code> object.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L357-L362" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def read(self) -&gt; bytes:
    &#34;&#34;&#34;Read the rest of the resource and return it in a `builtins.bytes` object.&#34;&#34;&#34;
    buff = bytearray()
    async for chunk in self:
        buff.extend(chunk)
    return buff</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.AsyncReaderContextManager" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="AsyncReaderContextManager -- Context manager that returns a reader." href="#hikari.files.AsyncReaderContextManager"
>AsyncReaderContextManager</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.AsyncReaderContextManager" class="hljs python"><abbr title='A standard Python type.'>class</abbr> AsyncReaderContextManager (
    *args,
    **kwds,
): ...</code></pre>
<p>Context manager that returns a reader.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L365-L392" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class AsyncReaderContextManager(abc.ABC, typing.Generic[ReaderImplT]):
    &#34;&#34;&#34;Context manager that returns a reader.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def __aenter__(self) -&gt; ReaderImplT:
        ...

    @abc.abstractmethod
    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        ...

    # These are only included at runtime in-order to avoid the model being typed as a synchronous context manager.
    if not typing.TYPE_CHECKING:

        def __enter__(self) -&gt; typing.NoReturn:
            # This is async only.
            cls = type(self)
            raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

        def __exit__(self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType) -&gt; None:
            return None</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="AsyncReaderContextManager -- Context manager that returns a reader." href="#hikari.files.AsyncReaderContextManager"
>AsyncReaderContextManager</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.Bytes" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="Bytes -- Representation of in-memory data to upload …" href="#hikari.files.Bytes"
>Bytes</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.Bytes" class="hljs python"><abbr title='A standard Python type.'>class</abbr> Bytes (
    data: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.files.Rawish'>Rawish</a>, <a href='#hikari.files.LazyByteIteratorish'>LazyByteIteratorish</a>],
    filename: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    /,
    mimetype: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
    *,
    spoiler: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
): ...</code></pre>
<p>Representation of in-memory data to upload.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.files.Rawish'>Rawish</a>, <a href='#hikari.files.LazyByteIteratorish'>LazyByteIteratorish</a>]</code></dt>
<dd>The raw data.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The filename to use.</dd>
<dt><strong><code>mimetype</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The mimetype, or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if you do not wish to specify this.
If not provided, then this will be generated from the file extension
of the filename instead.</dd>
<dt><strong><code>spoiler</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether to mark the file as a spoiler in Discord. Defaults to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L1004-L1127" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class Bytes(Resource[IteratorReader]):
    &#34;&#34;&#34;Representation of in-memory data to upload.

    Parameters
    ----------
    data : typing.Union[Rawish, LazyByteIteratorish]
        The raw data.
    filename : builtins.str
        The filename to use.
    mimetype : typing.Optional[builtins.str]
        The mimetype, or `builtins.None` if you do not wish to specify this.
        If not provided, then this will be generated from the file extension
        of the filename instead.
    spoiler : bool
        Whether to mark the file as a spoiler in Discord. Defaults to `builtins.False`.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;data&#34;, &#34;_filename&#34;, &#34;mimetype&#34;, &#34;is_spoiler&#34;)

    data: typing.Union[bytes, LazyByteIteratorish]
    &#34;&#34;&#34;The raw data/provider of raw data to upload.&#34;&#34;&#34;

    mimetype: typing.Optional[str]
    &#34;&#34;&#34;The provided mimetype, if provided. Otherwise `builtins.None`.&#34;&#34;&#34;

    is_spoiler: bool
    &#34;&#34;&#34;Whether the file will be marked as a spoiler.&#34;&#34;&#34;

    def __init__(
        self,
        data: typing.Union[Rawish, LazyByteIteratorish],
        filename: str,
        /,
        mimetype: typing.Optional[str] = None,
        *,
        spoiler: bool = False,
    ) -&gt; None:
        if isinstance(data, RAWISH_TYPES):
            data = unwrap_bytes(data)

        self.data = data

        if mimetype is None:
            mimetype = guess_mimetype_from_filename(filename)

        if mimetype is None:
            mimetype = &#34;text/plain;charset=UTF-8&#34;

        self._filename = filename
        self.mimetype = mimetype
        self.is_spoiler = spoiler

    @property
    def url(self) -&gt; str:
        return f&#34;attachment://{self.filename}&#34;

    @property
    def filename(self) -&gt; str:
        if self.is_spoiler:
            return SPOILER_TAG + self._filename

        return self._filename

    def stream(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        head_only: bool = False,
    ) -&gt; AsyncReaderContextManager[IteratorReader]:
        &#34;&#34;&#34;Start streaming the content in chunks.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            Not used. Provided only to match the underlying interface.
        head_only : builtins.bool
            Not used. Provided only to match the underlying interface.

        Returns
        -------
        AsyncReaderContextManager[IteratorReader]
            An async context manager that when entered, produces the
            data stream.
        &#34;&#34;&#34;
        return _NoOpAsyncReaderContextManagerImpl(IteratorReader(self.filename, self.mimetype, self.data))

    @staticmethod
    def from_data_uri(data_uri: str, filename: typing.Optional[str] = None) -&gt; Bytes:
        &#34;&#34;&#34;Parse a given data URI.

        Parameters
        ----------
        data_uri : builtins.str
            The data URI to parse.
        filename : typing.Optional[builtins.str]
            Filename to use. If this is not provided, then this is generated
            instead.

        Returns
        -------
        Bytes
            The parsed data URI as a `Bytes` object.

        Raises
        ------
        builtins.ValueError
            If the parsed argument is not a data URI.
        &#34;&#34;&#34;
        if not data_uri.startswith(&#34;data:&#34;):
            raise ValueError(&#34;Invalid data URI passed&#34;)

        # This will not block for a data URI; if it was a URL, it would block, so
        # we guard against this with the check above.
        try:
            with urllib.request.urlopen(data_uri) as response:  # noqa: S310   audit url open for permitted schemes
                mimetype, _ = mimetypes.guess_type(data_uri)
                data = response.read()
        except Exception as ex:
            raise ValueError(&#34;Failed to decode data URI&#34;) from ex

        if filename is None:
            filename = generate_filename_from_details(mimetype=mimetype, data=data)

        return Bytes(data, filename, mimetype=mimetype)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="Bytes -- Representation of in-memory data to upload …" href="#hikari.files.Bytes"
>Bytes</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></dt>
<dd class="nested"><p>Base for any uploadable or downloadable representation of information …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.Bytes.data" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="data -- The raw data/provider of raw data to upload." href="#hikari.files.Bytes.data"  >data</a> : Union[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>, AsyncIterator[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>], AsyncIterable[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>], Iterator[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>], Iterable[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>], AsyncIterator[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>], AsyncIterable[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>], Iterator[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>], Iterable[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>], AsyncGenerator[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>, Any], Generator[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>, Any, Any], AsyncGenerator[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, Any], Generator[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, Any, Any], streams.StreamReader, aiohttp.streams.StreamReader]</code></pre>
</dt>
<dd><p>The raw data/provider of raw data to upload.</p></dd>
</div>
<div id="hikari.files.Bytes.extension" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"  >extension</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>File extension, if there is one.</p></dd>
</div>
<div id="hikari.files.Bytes.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.Bytes.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Filename of the resource.</p></dd>
</div>
<div id="hikari.files.Bytes.is_spoiler" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_spoiler -- Whether the file will be marked as a spoiler." href="#hikari.files.Bytes.is_spoiler"  >is_spoiler</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd><p>Whether the file will be marked as a spoiler.</p></dd>
</div>
<div id="hikari.files.Bytes.mimetype" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The provided mimetype, if provided. Otherwise `builtins.None`." href="#hikari.files.Bytes.mimetype"  >mimetype</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The provided mimetype, if provided. Otherwise <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</p></dd>
</div>
<div id="hikari.files.Bytes.url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.Bytes.url"  >url</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>URL of the resource.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.Bytes.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.Resource.read" id="hikari.files.Bytes.read">read</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
) -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></code>.<code><a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a></code>
</p>
<p>Read the entire resource at once into memory.</p>
<pre><code class="language-py">data = await resource.read(...)
# ^-- This is a shortcut for the following --v
async with resource.stream(...) as reader:
    data = await reader.read()
</code></pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you simply wish to re-upload this resource to Discord via
any endpoint in Hikari, you should opt to just pass this
resource object directly. This way, Hikari can perform byte
inception, which significantly reduces the memory usage for
your bot as it grows larger.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to run in for blocking operations.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the default executor is used for the
current event loop.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>The entire resource.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.Bytes.stream" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="stream" href="#hikari.files.Bytes.stream" id="hikari.files.Bytes.stream">stream</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
    head_only: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> <a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.IteratorReader'>IteratorReader</a>]: ...</code></pre>
</dt>
<dd>
<p>Start streaming the content in chunks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>Not used. Provided only to match the underlying interface.</dd>
<dt><strong><code>head_only</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Not used. Provided only to match the underlying interface.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.IteratorReader'>IteratorReader</a>]</code></dt>
<dd>An async context manager that when entered, produces the
data stream.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L1067-L1088" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def stream(
    self,
    *,
    executor: typing.Optional[concurrent.futures.Executor] = None,
    head_only: bool = False,
) -&gt; AsyncReaderContextManager[IteratorReader]:
    &#34;&#34;&#34;Start streaming the content in chunks.

    Parameters
    ----------
    executor : typing.Optional[concurrent.futures.Executor]
        Not used. Provided only to match the underlying interface.
    head_only : builtins.bool
        Not used. Provided only to match the underlying interface.

    Returns
    -------
    AsyncReaderContextManager[IteratorReader]
        An async context manager that when entered, produces the
        data stream.
    &#34;&#34;&#34;
    return _NoOpAsyncReaderContextManagerImpl(IteratorReader(self.filename, self.mimetype, self.data))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.Bytes.from_data_uri" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="from_data_uri" href="#hikari.files.Bytes.from_data_uri" id="hikari.files.Bytes.from_data_uri">from_data_uri</a>(
    data_uri: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    filename: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
) -> <a href='#hikari.files.Bytes'>Bytes</a>: ...</code></pre>
</dt>
<dd>
<p>Parse a given data URI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_uri</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The data URI to parse.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>Filename to use. If this is not provided, then this is generated
instead.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.files.Bytes'>Bytes</a></code></dt>
<dd>The parsed data URI as a <code><a href='#hikari.files.Bytes'>Bytes</a></code> object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If the parsed argument is not a data URI.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L1090-L1127" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def from_data_uri(data_uri: str, filename: typing.Optional[str] = None) -&gt; Bytes:
    &#34;&#34;&#34;Parse a given data URI.

    Parameters
    ----------
    data_uri : builtins.str
        The data URI to parse.
    filename : typing.Optional[builtins.str]
        Filename to use. If this is not provided, then this is generated
        instead.

    Returns
    -------
    Bytes
        The parsed data URI as a `Bytes` object.

    Raises
    ------
    builtins.ValueError
        If the parsed argument is not a data URI.
    &#34;&#34;&#34;
    if not data_uri.startswith(&#34;data:&#34;):
        raise ValueError(&#34;Invalid data URI passed&#34;)

    # This will not block for a data URI; if it was a URL, it would block, so
    # we guard against this with the check above.
    try:
        with urllib.request.urlopen(data_uri) as response:  # noqa: S310   audit url open for permitted schemes
            mimetype, _ = mimetypes.guess_type(data_uri)
            data = response.read()
    except Exception as ex:
        raise ValueError(&#34;Failed to decode data URI&#34;) from ex

    if filename is None:
        filename = generate_filename_from_details(mimetype=mimetype, data=data)

    return Bytes(data, filename, mimetype=mimetype)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.File" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="File -- A resource that exists on the local machine's storage to be uploaded …" href="#hikari.files.File"
>File</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.File" class="hljs python"><abbr title='A standard Python type.'>class</abbr> File (
    path: <a href='#hikari.files.Pathish'>Pathish</a>,
    /,
    filename: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
    *,
    spoiler: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
): ...</code></pre>
<p>A resource that exists on the local machine's storage to be uploaded.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/os.html#os.PathLike'>os.PathLike</a>, <a href='https://docs.python.org/3/library/pathlib.html#pathlib.Path'>pathlib.Path</a>]</code></dt>
<dd>
<p>The path to use.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>If passing a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.Path'>pathlib.Path</a></code>, this must not be a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code>
directly, as it will be used to expand tokens such as <code>~</code> that
denote the home directory, and <code>..</code> for relative paths.</p>
<p>This will all be performed as required in an executor to prevent
blocking the event loop.</p>
</div>
</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The filename to use. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, the name of the file is taken
from the path instead.</dd>
<dt><strong><code>spoiler</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether to mark the file as a spoiler in Discord. Defaults to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L846-L924" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class File(Resource[FileReader]):
    &#34;&#34;&#34;A resource that exists on the local machine&#39;s storage to be uploaded.

    Parameters
    ----------
    path : typing.Union[builtins.str, os.PathLike, pathlib.Path]
        The path to use.

        !!! note
            If passing a `pathlib.Path`, this must not be a `pathlib.PurePath`
            directly, as it will be used to expand tokens such as `~` that
            denote the home directory, and `..` for relative paths.

            This will all be performed as required in an executor to prevent
            blocking the event loop.
    filename : typing.Optional[builtins.str]
        The filename to use. If this is `builtins.None`, the name of the file is taken
        from the path instead.
    spoiler : bool
        Whether to mark the file as a spoiler in Discord. Defaults to `builtins.False`.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;path&#34;, &#34;_filename&#34;, &#34;is_spoiler&#34;)

    path: pathlib.Path
    &#34;&#34;&#34;The path to the file.&#34;&#34;&#34;

    is_spoiler: bool
    &#34;&#34;&#34;Whether the file will be marked as a spoiler.&#34;&#34;&#34;

    _filename: typing.Optional[str]

    def __init__(self, path: Pathish, /, filename: typing.Optional[str] = None, *, spoiler: bool = False) -&gt; None:
        self.path = ensure_path(path)
        self.is_spoiler = spoiler
        self._filename = filename

    @property
    @typing.final
    def url(self) -&gt; str:
        return f&#34;attachment://{self.filename}&#34;

    @property
    def filename(self) -&gt; str:
        filename = self._filename if self._filename else self.path.name

        if self.is_spoiler:
            return SPOILER_TAG + filename

        return filename

    def stream(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        head_only: bool = False,
    ) -&gt; AsyncReaderContextManager[FileReader]:
        &#34;&#34;&#34;Start streaming the resource using a thread pool executor.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            The executor to run the blocking read operations in. If
            `builtins.None`, the default executor for the running event loop
            will be used instead.
        head_only : builtins.bool
            Not used. Provided only to match the underlying interface.

        Returns
        -------
        AsyncReaderContextManager[FileReader]
            An async context manager that when entered, produces the
            data stream.
        &#34;&#34;&#34;
        # asyncio forces the default executor when this is None to always be a thread pool executor anyway,
        # so this is safe enough to do.:
        is_threaded = executor is None or isinstance(executor, concurrent.futures.ThreadPoolExecutor)
        impl = ThreadedFileReader if is_threaded else MultiprocessingFileReader
        return _NoOpAsyncReaderContextManagerImpl(impl(self.filename, None, executor, self.path))</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="File -- A resource that exists on the local machine's storage to be uploaded …" href="#hikari.files.File"
>File</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></dt>
<dd class="nested"><p>Base for any uploadable or downloadable representation of information …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.File.extension" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"  >extension</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>File extension, if there is one.</p></dd>
</div>
<div id="hikari.files.File.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.File.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Filename of the resource.</p></dd>
</div>
<div id="hikari.files.File.is_spoiler" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_spoiler -- Whether the file will be marked as a spoiler." href="#hikari.files.File.is_spoiler"  >is_spoiler</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd><p>Whether the file will be marked as a spoiler.</p></dd>
</div>
<div id="hikari.files.File.path" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="path -- The path to the file." href="#hikari.files.File.path"  >path</a> : <a href='https://docs.python.org/3/library/pathlib.html#pathlib.Path'>pathlib.Path</a></code></pre>
</dt>
<dd><p>The path to the file.</p></dd>
</div>
<div id="hikari.files.File.url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.File.url"  >url</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>URL of the resource.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.File.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.Resource.read" id="hikari.files.File.read">read</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
) -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></code>.<code><a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a></code>
</p>
<p>Read the entire resource at once into memory.</p>
<pre><code class="language-py">data = await resource.read(...)
# ^-- This is a shortcut for the following --v
async with resource.stream(...) as reader:
    data = await reader.read()
</code></pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you simply wish to re-upload this resource to Discord via
any endpoint in Hikari, you should opt to just pass this
resource object directly. This way, Hikari can perform byte
inception, which significantly reduces the memory usage for
your bot as it grows larger.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to run in for blocking operations.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the default executor is used for the
current event loop.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>The entire resource.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.File.stream" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="stream" href="#hikari.files.File.stream" id="hikari.files.File.stream">stream</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
    head_only: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> <a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.FileReader'>FileReader</a>]: ...</code></pre>
</dt>
<dd>
<p>Start streaming the resource using a thread pool executor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to run the blocking read operations in. If
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, the default executor for the running event loop
will be used instead.</dd>
<dt><strong><code>head_only</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Not used. Provided only to match the underlying interface.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.FileReader'>FileReader</a>]</code></dt>
<dd>An async context manager that when entered, produces the
data stream.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L897-L924" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def stream(
    self,
    *,
    executor: typing.Optional[concurrent.futures.Executor] = None,
    head_only: bool = False,
) -&gt; AsyncReaderContextManager[FileReader]:
    &#34;&#34;&#34;Start streaming the resource using a thread pool executor.

    Parameters
    ----------
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to run the blocking read operations in. If
        `builtins.None`, the default executor for the running event loop
        will be used instead.
    head_only : builtins.bool
        Not used. Provided only to match the underlying interface.

    Returns
    -------
    AsyncReaderContextManager[FileReader]
        An async context manager that when entered, produces the
        data stream.
    &#34;&#34;&#34;
    # asyncio forces the default executor when this is None to always be a thread pool executor anyway,
    # so this is safe enough to do.:
    is_threaded = executor is None or isinstance(executor, concurrent.futures.ThreadPoolExecutor)
    impl = ThreadedFileReader if is_threaded else MultiprocessingFileReader
    return _NoOpAsyncReaderContextManagerImpl(impl(self.filename, None, executor, self.path))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.FileReader" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="FileReader -- Abstract base for a file reader object …" href="#hikari.files.FileReader"
>FileReader</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.FileReader" class="hljs python"><abbr title='A standard Python type.'>class</abbr> FileReader (
    filename: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    mimetype: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>],
    path: <a href='#hikari.files.Pathish'>Pathish</a>,
): ...</code></pre>
<p>Abstract base for a file reader object.</p>
<p>Various implementations have to exist in order to cater for situations
where we cannot pass IO objects around (e.g. ProcessPoolExecutors, since
they pickle things).</p>
<p>Method generated by attrs for class FileReader.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L756-L768" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class FileReader(AsyncReader, abc.ABC):
    &#34;&#34;&#34;Abstract base for a file reader object.

    Various implementations have to exist in order to cater for situations
    where we cannot pass IO objects around (e.g. ProcessPoolExecutors, since
    they pickle things).
    &#34;&#34;&#34;

    executor: typing.Optional[concurrent.futures.Executor] = attr.field()
    &#34;&#34;&#34;The associated `concurrent.futures.Executor` to use for blocking IO.&#34;&#34;&#34;

    path: pathlib.Path = attr.field(converter=ensure_path)
    &#34;&#34;&#34;The path to the resource to read.&#34;&#34;&#34;</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="FileReader -- Abstract base for a file reader object …" href="#hikari.files.FileReader"
>FileReader</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></dt>
<dd class="nested"><p>Protocol for reading a resource asynchronously using bit inception …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="collections.abc.AsyncIterable -- " href="https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncIterable"
>collections.abc.AsyncIterable</a></dt>
<dd class="nested"></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.FileReader.executor" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="executor -- The associated `concurrent.futures.Executor` to use for blocking IO." href="#hikari.files.FileReader.executor"  >executor</a> : Optional[concurrent.futures._base.Executor]</code></pre>
</dt>
<dd><p>The associated <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a></code> to use for blocking IO.</p></dd>
</div>
<div id="hikari.files.FileReader.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- The filename of the resource." href="#hikari.files.FileReader.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The filename of the resource.</p></dd>
</div>
<div id="hikari.files.FileReader.mimetype" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The mimetype of the resource. May be `builtins.None` if not known." href="#hikari.files.FileReader.mimetype"  >mimetype</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The mimetype of the resource. May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if not known.</p></dd>
</div>
<div id="hikari.files.FileReader.path" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="path -- The path to the resource to read." href="#hikari.files.FileReader.path"  >path</a> : <a href='https://docs.python.org/3/library/pathlib.html#pathlib.Path'>pathlib.Path</a></code></pre>
</dt>
<dd><p>The path to the resource to read.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.FileReader.data_uri" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="data_uri" href="#hikari.files.AsyncReader.data_uri" id="hikari.files.FileReader.data_uri">data_uri</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></code>.<code><a title="data_uri -- Fetch the data URI …" href="#hikari.files.AsyncReader.data_uri"
>data_uri</a></code>
</p>
<p>Fetch the data URI.</p>
<p>This reads the entire resource.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.FileReader.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.AsyncReader.read" id="hikari.files.FileReader.read">read</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></code>.<code><a title="read -- Read the rest of the resource and return it in a `builtins.bytes` object." href="#hikari.files.AsyncReader.read"
>read</a></code>
</p>
<p>Read the rest of the resource and return it in a <code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code> object.</p>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.IteratorReader" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IteratorReader -- Asynchronous file reader that operates on in-memory data …" href="#hikari.files.IteratorReader"
>IteratorReader</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.IteratorReader" class="hljs python"><abbr title='A standard Python type.'>class</abbr> IteratorReader (
    filename: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    mimetype: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    data: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>, <a href='#hikari.files.LazyByteIteratorish'>LazyByteIteratorish</a>],
): ...</code></pre>
<p>Asynchronous file reader that operates on in-memory data.</p>
<p>Method generated by attrs for class IteratorReader.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L933-L1001" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class IteratorReader(AsyncReader):
    &#34;&#34;&#34;Asynchronous file reader that operates on in-memory data.&#34;&#34;&#34;

    data: typing.Union[bytes, LazyByteIteratorish] = attr.field()
    &#34;&#34;&#34;The data that will be yielded in chunks.&#34;&#34;&#34;

    async def __aiter__(self) -&gt; typing.AsyncGenerator[typing.Any, bytes]:
        buff = bytearray()
        iterator = self._wrap_iter()

        while True:
            try:
                while len(buff) &lt; _MAGIC:
                    chunk = await iterator.__anext__()
                    buff.extend(chunk)
                yield bytes(buff)
                buff.clear()
            except StopAsyncIteration:
                break

        if buff:
            yield bytes(buff)

    async def _wrap_iter(self) -&gt; typing.AsyncGenerator[typing.Any, bytes]:
        if isinstance(self.data, bytes):
            for i in range(0, len(self.data), _MAGIC):
                yield self.data[i : i + _MAGIC]  # noqa: E203 - Whitespace before &#34;:&#34;

        elif aio.is_async_iterator(self.data) or inspect.isasyncgen(self.data):
            try:
                while True:
                    yield self._assert_bytes(await self.data.__anext__())  # type: ignore[union-attr]
            except StopAsyncIteration:
                pass

        elif isinstance(self.data, typing.Iterator):
            try:
                while True:
                    yield self._assert_bytes(next(self.data))
            except StopIteration:
                pass

        elif inspect.isgenerator(self.data):
            try:
                while True:
                    yield self._assert_bytes(self.data.send(None))  # type: ignore[union-attr]
            except StopIteration:
                pass

        elif aio.is_async_iterable(self.data):
            async for chunk in self.data:
                yield self._assert_bytes(chunk)

        elif isinstance(self.data, typing.Iterable):
            for chunk in self.data:
                yield self._assert_bytes(chunk)

        else:
            # Will always fail.
            self._assert_bytes(self.data)

    @staticmethod
    def _assert_bytes(data: typing.Any) -&gt; bytes:
        if isinstance(data, str):
            return bytes(data, &#34;utf-8&#34;)

        if not isinstance(data, bytes):
            raise TypeError(f&#34;Expected bytes but received {type(data).__name__}&#34;)
        return data</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IteratorReader -- Asynchronous file reader that operates on in-memory data …" href="#hikari.files.IteratorReader"
>IteratorReader</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></dt>
<dd class="nested"><p>Protocol for reading a resource asynchronously using bit inception …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="collections.abc.AsyncIterable -- " href="https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncIterable"
>collections.abc.AsyncIterable</a></dt>
<dd class="nested"></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.IteratorReader.data" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="data -- The data that will be yielded in chunks." href="#hikari.files.IteratorReader.data"  >data</a> : Union[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>, AsyncIterator[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>], AsyncIterable[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>], Iterator[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>], Iterable[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>], AsyncIterator[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>], AsyncIterable[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>], Iterator[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>], Iterable[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>], AsyncGenerator[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>, Any], Generator[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>, Any, Any], AsyncGenerator[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, Any], Generator[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, Any, Any], streams.StreamReader, aiohttp.streams.StreamReader]</code></pre>
</dt>
<dd><p>The data that will be yielded in chunks.</p></dd>
</div>
<div id="hikari.files.IteratorReader.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- The filename of the resource." href="#hikari.files.IteratorReader.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The filename of the resource.</p></dd>
</div>
<div id="hikari.files.IteratorReader.mimetype" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The mimetype of the resource. May be `builtins.None` if not known." href="#hikari.files.IteratorReader.mimetype"  >mimetype</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The mimetype of the resource. May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if not known.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.IteratorReader.data_uri" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="data_uri" href="#hikari.files.AsyncReader.data_uri" id="hikari.files.IteratorReader.data_uri">data_uri</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></code>.<code><a title="data_uri -- Fetch the data URI …" href="#hikari.files.AsyncReader.data_uri"
>data_uri</a></code>
</p>
<p>Fetch the data URI.</p>
<p>This reads the entire resource.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.IteratorReader.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.AsyncReader.read" id="hikari.files.IteratorReader.read">read</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></code>.<code><a title="read -- Read the rest of the resource and return it in a `builtins.bytes` object." href="#hikari.files.AsyncReader.read"
>read</a></code>
</p>
<p>Read the rest of the resource and return it in a <code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code> object.</p>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.Resource" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.Resource" class="hljs python"><abbr title='A standard Python type.'>class</abbr> Resource (
    *args,
    **kwds,
): ...</code></pre>
<p>Base for any uploadable or downloadable representation of information.</p>
<p>These representations can be streamed using bit inception for performance,
which may result in significant decrease in memory usage for larger
resources.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L412-L515" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class Resource(typing.Generic[ReaderImplT], abc.ABC):
    &#34;&#34;&#34;Base for any uploadable or downloadable representation of information.

    These representations can be streamed using bit inception for performance,
    which may result in significant decrease in memory usage for larger
    resources.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @property
    @abc.abstractmethod
    def url(self) -&gt; str:
        &#34;&#34;&#34;URL of the resource.&#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def filename(self) -&gt; str:
        &#34;&#34;&#34;Filename of the resource.&#34;&#34;&#34;

    @property
    def extension(self) -&gt; typing.Optional[str]:
        &#34;&#34;&#34;File extension, if there is one.&#34;&#34;&#34;
        _, _, ext = self.filename.rpartition(&#34;.&#34;)
        return ext if ext != self.filename else None

    async def read(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;Read the entire resource at once into memory.

        ```py
        data = await resource.read(...)
        # ^-- This is a shortcut for the following --v
        async with resource.stream(...) as reader:
            data = await reader.read()
        ```

        !!! warning
            If you simply wish to re-upload this resource to Discord via
            any endpoint in Hikari, you should opt to just pass this
            resource object directly. This way, Hikari can perform byte
            inception, which significantly reduces the memory usage for
            your bot as it grows larger.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            The executor to run in for blocking operations.
            If `builtins.None`, then the default executor is used for the
            current event loop.

        Returns
        -------
        builtins.bytes
            The entire resource.
        &#34;&#34;&#34;
        async with self.stream(executor=executor) as reader:
            return await reader.read()

    @abc.abstractmethod
    def stream(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        head_only: bool = False,
    ) -&gt; AsyncReaderContextManager[ReaderImplT]:
        &#34;&#34;&#34;Produce a stream of data for the resource.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            The executor to run in for blocking operations.
            If `builtins.None`, then the default executor is used for the
            current event loop.
        head_only : builtins.bool
            Defaults to `builtins.False`. If `builtins.True`, then the
            implementation may only retrieve HEAD information if supported.
            This currently only has any effect for web requests. This will
            fetch the headers for the HTTP resource this object points to
            without downloading the entire content, which can be significantly
            faster if you are scanning file types in messages, for example.

        Returns
        -------
        AsyncReaderContextManager[AsyncReader]
            An async iterable of bytes to stream.
        &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return self.url

    def __repr__(self) -&gt; str:
        return f&#34;{type(self).__name__}(url={self.url!r}, filename={self.filename!r})&#34;

    def __eq__(self, other: typing.Any) -&gt; bool:
        if isinstance(other, Resource):
            return self.url == other.url
        return False

    def __hash__(self) -&gt; int:
        return hash((self.__class__, self.url))</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="EmbedResource -- A base type for any resource provided in an embed …" href="embeds.html#hikari.embeds.EmbedResource"
>EmbedResource</a></dt>
<dd class="nested"><p>A base type for any resource provided in an embed …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="Bytes -- Representation of in-memory data to upload …" href="#hikari.files.Bytes"
>Bytes</a></dt>
<dd class="nested"><p>Representation of in-memory data to upload …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="File -- A resource that exists on the local machine's storage to be uploaded …" href="#hikari.files.File"
>File</a></dt>
<dd class="nested"><p>A resource that exists on the local machine's storage to be uploaded …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="WebResource -- Base class for a resource that resides on the internet …" href="#hikari.files.WebResource"
>WebResource</a></dt>
<dd class="nested"><p>Base class for a resource that resides on the internet …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.Resource.extension" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"  >extension</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>File extension, if there is one.</p></dd>
</div>
<div id="hikari.files.Resource.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.Resource.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Filename of the resource.</p></dd>
</div>
<div id="hikari.files.Resource.url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.Resource.url"  >url</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>URL of the resource.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.Resource.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.Resource.read" id="hikari.files.Resource.read">read</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
) -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p>Read the entire resource at once into memory.</p>
<pre><code class="language-py">data = await resource.read(...)
# ^-- This is a shortcut for the following --v
async with resource.stream(...) as reader:
    data = await reader.read()
</code></pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you simply wish to re-upload this resource to Discord via
any endpoint in Hikari, you should opt to just pass this
resource object directly. This way, Hikari can perform byte
inception, which significantly reduces the memory usage for
your bot as it grows larger.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to run in for blocking operations.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the default executor is used for the
current event loop.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>The entire resource.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L438-L472" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def read(
    self,
    *,
    executor: typing.Optional[concurrent.futures.Executor] = None,
) -&gt; bytes:
    &#34;&#34;&#34;Read the entire resource at once into memory.

    ```py
    data = await resource.read(...)
    # ^-- This is a shortcut for the following --v
    async with resource.stream(...) as reader:
        data = await reader.read()
    ```

    !!! warning
        If you simply wish to re-upload this resource to Discord via
        any endpoint in Hikari, you should opt to just pass this
        resource object directly. This way, Hikari can perform byte
        inception, which significantly reduces the memory usage for
        your bot as it grows larger.

    Parameters
    ----------
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to run in for blocking operations.
        If `builtins.None`, then the default executor is used for the
        current event loop.

    Returns
    -------
    builtins.bytes
        The entire resource.
    &#34;&#34;&#34;
    async with self.stream(executor=executor) as reader:
        return await reader.read()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.Resource.stream" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="stream" href="#hikari.files.Resource.stream" id="hikari.files.Resource.stream">stream</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
    head_only: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> <a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[~ReaderImplT]: ...</code></pre>
</dt>
<dd>
<p>Produce a stream of data for the resource.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to run in for blocking operations.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the default executor is used for the
current event loop.</dd>
<dt><strong><code>head_only</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Defaults to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then the
implementation may only retrieve HEAD information if supported.
This currently only has any effect for web requests. This will
fetch the headers for the HTTP resource this object points to
without downloading the entire content, which can be significantly
faster if you are scanning file types in messages, for example.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.AsyncReader'>AsyncReader</a>]</code></dt>
<dd>An async iterable of bytes to stream.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L474-L501" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def stream(
    self,
    *,
    executor: typing.Optional[concurrent.futures.Executor] = None,
    head_only: bool = False,
) -&gt; AsyncReaderContextManager[ReaderImplT]:
    &#34;&#34;&#34;Produce a stream of data for the resource.

    Parameters
    ----------
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to run in for blocking operations.
        If `builtins.None`, then the default executor is used for the
        current event loop.
    head_only : builtins.bool
        Defaults to `builtins.False`. If `builtins.True`, then the
        implementation may only retrieve HEAD information if supported.
        This currently only has any effect for web requests. This will
        fetch the headers for the HTTP resource this object points to
        without downloading the entire content, which can be significantly
        faster if you are scanning file types in messages, for example.

    Returns
    -------
    AsyncReaderContextManager[AsyncReader]
        An async iterable of bytes to stream.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.URL" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="URL -- A URL that represents a web resource …" href="#hikari.files.URL"
>URL</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.URL" class="hljs python"><abbr title='A standard Python type.'>class</abbr> URL (
    url: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
): ...</code></pre>
<p>A URL that represents a web resource.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The URL of the resource.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Some components may choose to not upload this resource directly and
instead simply refer to the URL as needed. The main place this will
occur is within embeds.</p>
<p>If you need to re-upload the resource, you should download it into
a <code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code> and pass that instead in these cases.</p>
</div>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L718-L747" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class URL(WebResource):
    &#34;&#34;&#34;A URL that represents a web resource.

    Parameters
    ----------
    url : builtins.str
        The URL of the resource.

    !!! note
        Some components may choose to not upload this resource directly and
        instead simply refer to the URL as needed. The main place this will
        occur is within embeds.

        If you need to re-upload the resource, you should download it into
        a `builtins.bytes` and pass that instead in these cases.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_url&#34;,)

    def __init__(self, url: str) -&gt; None:
        self._url = url

    @property
    def url(self) -&gt; str:
        return self._url

    @property
    def filename(self) -&gt; str:
        url = urllib.parse.urlparse(self._url)
        return os.path.basename(url.path)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="URL -- A URL that represents a web resource …" href="#hikari.files.URL"
>URL</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="WebResource -- Base class for a resource that resides on the internet …" href="#hikari.files.WebResource"
>WebResource</a></dt>
<dd class="nested"><p>Base class for a resource that resides on the internet …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></dt>
<dd class="nested"><p>Base for any uploadable or downloadable representation of information …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.URL.extension" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"  >extension</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>File extension, if there is one.</p></dd>
</div>
<div id="hikari.files.URL.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.URL.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Filename of the resource.</p></dd>
</div>
<div id="hikari.files.URL.url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.URL.url"  >url</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>URL of the resource.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.URL.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.Resource.read" id="hikari.files.URL.read">read</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
) -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="WebResource -- Base class for a resource that resides on the internet …" href="#hikari.files.WebResource"
>WebResource</a></code>.<code><a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a></code>
</p>
<p>Read the entire resource at once into memory.</p>
<pre><code class="language-py">data = await resource.read(...)
# ^-- This is a shortcut for the following --v
async with resource.stream(...) as reader:
    data = await reader.read()
</code></pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you simply wish to re-upload this resource to Discord via
any endpoint in Hikari, you should opt to just pass this
resource object directly. This way, Hikari can perform byte
inception, which significantly reduces the memory usage for
your bot as it grows larger.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to run in for blocking operations.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the default executor is used for the
current event loop.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>The entire resource.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.URL.stream" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="stream" href="#hikari.files.WebResource.stream" id="hikari.files.URL.stream">stream</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
    head_only: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> <a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.WebReader'>WebReader</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="WebResource -- Base class for a resource that resides on the internet …" href="#hikari.files.WebResource"
>WebResource</a></code>.<code><a title="stream -- Start streaming the content into memory by downloading it …" href="#hikari.files.WebResource.stream"
>stream</a></code>
</p>
<p>Start streaming the content into memory by downloading it.</p>
<p>You can use this to fetch the entire resource, parts of the resource,
or just to view any metadata that may be provided.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>Not used. Provided only to match the underlying interface.</dd>
<dt><strong><code>head_only</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Defaults to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then the
implementation may only retrieve HEAD information if supported.
This currently only has any effect for web requests.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Downloading an entire resource at once into memory:</p>
<pre><code class="language-py">async with obj.stream() as stream:
    data = await stream.read()
</code></pre>
<p>Checking the metadata:</p>
<pre><code class="language-py">async with obj.stream() as stream:
    mimetype = stream.mimetype

if mimetype is None:
    ...
elif mimetype not in whitelisted_mimetypes:
    ...
else:
    ...
</code></pre>
<p>Fetching the data-uri of a resource:</p>
<pre><code class="language-py">async with obj.stream() as stream:
    data_uri = await stream.data_uri()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.WebReader'>WebReader</a>]</code></dt>
<dd>An async context manager that when entered, produces the
data stream.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If a 400 is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If a 401 is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If a 403 is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If a 404 is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.ClientHTTPResponseError'>ClientHTTPResponseError</a></code></dt>
<dd>If any other 4xx is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If any other 5xx is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.HTTPResponseError'>HTTPResponseError</a></code></dt>
<dd>If any other unexpected response code is returned.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.WebReader" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="WebReader -- Asynchronous reader to use to read data from a web resource …" href="#hikari.files.WebReader"
>WebReader</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.WebReader" class="hljs python"><abbr title='A standard Python type.'>class</abbr> WebReader (
    filename: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    mimetype: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    stream: <a href='https://docs.aiohttp.org/en/stable/streams.html#aiohttp.StreamReader'>aiohttp.StreamReader</a>,
    url: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    status: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
    reason: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    charset: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    size: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>],
    head_only: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>,
): ...</code></pre>
<p>Asynchronous reader to use to read data from a web resource.</p>
<p>Method generated by attrs for class WebReader.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L524-L561" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class WebReader(AsyncReader):
    &#34;&#34;&#34;Asynchronous reader to use to read data from a web resource.&#34;&#34;&#34;

    stream: aiohttp.StreamReader = attr.field(repr=False)
    &#34;&#34;&#34;The `aiohttp.StreamReader` to read the content from.&#34;&#34;&#34;

    url: str = attr.field(repr=False)
    &#34;&#34;&#34;The URL being read from.&#34;&#34;&#34;

    status: int = attr.field()
    &#34;&#34;&#34;The initial HTTP response status.&#34;&#34;&#34;

    reason: str = attr.field()
    &#34;&#34;&#34;The HTTP response status reason.&#34;&#34;&#34;

    charset: typing.Optional[str] = attr.field()
    &#34;&#34;&#34;Optional character set information, if known.&#34;&#34;&#34;

    size: typing.Optional[int] = attr.field()
    &#34;&#34;&#34;The size of the resource, if known.&#34;&#34;&#34;

    head_only: bool = attr.field()
    &#34;&#34;&#34;If `builtins.True`, then only the HEAD was requested.

    In this case, neither `__aiter__` nor `read` would return anything other
    than an empty byte string.
    &#34;&#34;&#34;

    async def read(self) -&gt; bytes:
        return b&#34;&#34; if self.head_only else await self.stream.read()

    async def __aiter__(self) -&gt; typing.AsyncGenerator[typing.Any, bytes]:
        if self.head_only:
            yield b&#34;&#34;
        else:
            while not self.stream.at_eof():
                chunk, _ = await self.stream.readchunk()
                yield chunk</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="WebReader -- Asynchronous reader to use to read data from a web resource …" href="#hikari.files.WebReader"
>WebReader</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></dt>
<dd class="nested"><p>Protocol for reading a resource asynchronously using bit inception …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="collections.abc.AsyncIterable -- " href="https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncIterable"
>collections.abc.AsyncIterable</a></dt>
<dd class="nested"></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.WebReader.charset" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="charset -- Optional character set information, if known." href="#hikari.files.WebReader.charset"  >charset</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>Optional character set information, if known.</p></dd>
</div>
<div id="hikari.files.WebReader.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- The filename of the resource." href="#hikari.files.WebReader.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The filename of the resource.</p></dd>
</div>
<div id="hikari.files.WebReader.head_only" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="head_only -- If `builtins.True`, then only the HEAD was requested …" href="#hikari.files.WebReader.head_only"  >head_only</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd><p>If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then only the HEAD was requested.</p>
<p>In this case, neither <code>__aiter__</code> nor <code>read</code> would return anything other
than an empty byte string.</p></dd>
</div>
<div id="hikari.files.WebReader.mimetype" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mimetype -- The mimetype of the resource. May be `builtins.None` if not known." href="#hikari.files.WebReader.mimetype"  >mimetype</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The mimetype of the resource. May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if not known.</p></dd>
</div>
<div id="hikari.files.WebReader.reason" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="reason -- The HTTP response status reason." href="#hikari.files.WebReader.reason"  >reason</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The HTTP response status reason.</p></dd>
</div>
<div id="hikari.files.WebReader.size" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="size -- The size of the resource, if known." href="#hikari.files.WebReader.size"  >size</a> : Optional[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></pre>
</dt>
<dd><p>The size of the resource, if known.</p></dd>
</div>
<div id="hikari.files.WebReader.status" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="status -- The initial HTTP response status." href="#hikari.files.WebReader.status"  >status</a> : <a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></pre>
</dt>
<dd><p>The initial HTTP response status.</p></dd>
</div>
<div id="hikari.files.WebReader.stream" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="stream -- The `aiohttp.StreamReader` to read the content from." href="#hikari.files.WebReader.stream"  >stream</a> : aiohttp.streams.StreamReader</code></pre>
</dt>
<dd><p>The <code><a href='https://docs.aiohttp.org/en/stable/streams.html#aiohttp.StreamReader'>aiohttp.StreamReader</a></code> to read the content from.</p></dd>
</div>
<div id="hikari.files.WebReader.url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- The URL being read from." href="#hikari.files.WebReader.url"  >url</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The URL being read from.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.WebReader.data_uri" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="data_uri" href="#hikari.files.AsyncReader.data_uri" id="hikari.files.WebReader.data_uri">data_uri</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></code>.<code><a title="data_uri -- Fetch the data URI …" href="#hikari.files.AsyncReader.data_uri"
>data_uri</a></code>
</p>
<p>Fetch the data URI.</p>
<p>This reads the entire resource.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.WebReader.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.WebReader.read" id="hikari.files.WebReader.read">read</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="AsyncReader -- Protocol for reading a resource asynchronously using bit inception …" href="#hikari.files.AsyncReader"
>AsyncReader</a></code>.<code><a title="read -- Read the rest of the resource and return it in a `builtins.bytes` object." href="#hikari.files.AsyncReader.read"
>read</a></code>
</p>
<p>Read the rest of the resource and return it in a <code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code> object.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L552-L553" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def read(self) -&gt; bytes:
    return b&#34;&#34; if self.head_only else await self.stream.read()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.files.WebResource" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="WebResource -- Base class for a resource that resides on the internet …" href="#hikari.files.WebResource"
>WebResource</a></h4>
</dt>
<dd>
<pre><code id="hikari.files.WebResource" class="hljs python"><abbr title='A standard Python type.'>class</abbr> WebResource (
    *args,
    **kwds,
): ...</code></pre>
<p>Base class for a resource that resides on the internet.</p>
<p>The logic for identifying this resource is left to each implementation
to define.</p>
<div class="alert alert-primary">
<p class="admonition-title">Info</p>
<p>For a usable concrete implementation, use <code><a href='#hikari.files.URL'>URL</a></code> instead.</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Some components may choose to not upload this resource directly and
instead simply refer to the URL as needed. The main place this will
occur is within embeds.</p>
<p>If you need to re-upload the resource, you should download it into
a <code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code> and pass that instead in these cases.</p>
</div>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L626-L714" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class WebResource(Resource[WebReader], abc.ABC):
    &#34;&#34;&#34;Base class for a resource that resides on the internet.

    The logic for identifying this resource is left to each implementation
    to define.

    !!! info
        For a usable concrete implementation, use `URL` instead.

    !!! note
        Some components may choose to not upload this resource directly and
        instead simply refer to the URL as needed. The main place this will
        occur is within embeds.

        If you need to re-upload the resource, you should download it into
        a `builtins.bytes` and pass that instead in these cases.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def stream(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        head_only: bool = False,
    ) -&gt; AsyncReaderContextManager[WebReader]:
        &#34;&#34;&#34;Start streaming the content into memory by downloading it.

        You can use this to fetch the entire resource, parts of the resource,
        or just to view any metadata that may be provided.

        Parameters
        ----------
        executor : typing.Optional[concurrent.futures.Executor]
            Not used. Provided only to match the underlying interface.
        head_only : builtins.bool
            Defaults to `builtins.False`. If `builtins.True`, then the
            implementation may only retrieve HEAD information if supported.
            This currently only has any effect for web requests.

        Examples
        --------
        Downloading an entire resource at once into memory:
        ```py
        async with obj.stream() as stream:
            data = await stream.read()
        ```
        Checking the metadata:
        ```py
        async with obj.stream() as stream:
            mimetype = stream.mimetype

        if mimetype is None:
            ...
        elif mimetype not in whitelisted_mimetypes:
            ...
        else:
            ...
        ```
        Fetching the data-uri of a resource:
        ```py
        async with obj.stream() as stream:
            data_uri = await stream.data_uri()
        ```

        Returns
        -------
        AsyncReaderContextManager[WebReader]
            An async context manager that when entered, produces the
            data stream.

        Raises
        ------
        hikari.errors.BadRequestError
            If a 400 is returned.
        hikari.errors.UnauthorizedError
            If a 401 is returned.
        hikari.errors.ForbiddenError
            If a 403 is returned.
        hikari.errors.NotFoundError
            If a 404 is returned.
        hikari.errors.ClientHTTPResponseError
            If any other 4xx is returned.
        hikari.errors.InternalServerError
            If any other 5xx is returned.
        hikari.errors.HTTPResponseError
            If any other unexpected response code is returned.
        &#34;&#34;&#34;
        return _WebReaderAsyncReaderContextManagerImpl(self, head_only)</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Emoji -- Base class for all emojis …" href="emojis.html#hikari.emojis.Emoji"
>Emoji</a></dt>
<dd class="nested"><p>Base class for all emojis …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="URL -- A URL that represents a web resource …" href="#hikari.files.URL"
>URL</a></dt>
<dd class="nested"><p>A URL that represents a web resource …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="Attachment -- Represents a file attached to a message …" href="messages.html#hikari.messages.Attachment"
>Attachment</a></dt>
<dd class="nested"><p>Represents a file attached to a message …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="WebResource -- Base class for a resource that resides on the internet …" href="#hikari.files.WebResource"
>WebResource</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></dt>
<dd class="nested"><p>Base for any uploadable or downloadable representation of information …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.files.WebResource.extension" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="extension -- File extension, if there is one." href="#hikari.files.Resource.extension"  >extension</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>File extension, if there is one.</p></dd>
</div>
<div id="hikari.files.WebResource.filename" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Filename of the resource." href="#hikari.files.Resource.filename"  >filename</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Filename of the resource.</p></dd>
</div>
<div id="hikari.files.WebResource.url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="url -- URL of the resource." href="#hikari.files.Resource.url"  >url</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>URL of the resource.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.files.WebResource.read" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="read" href="#hikari.files.Resource.read" id="hikari.files.WebResource.read">read</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
) -> <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="Resource -- Base for any uploadable or downloadable representation of information …" href="#hikari.files.Resource"
>Resource</a></code>.<code><a title="read -- Read the entire resource at once into memory …" href="#hikari.files.Resource.read"
>read</a></code>
</p>
<p>Read the entire resource at once into memory.</p>
<pre><code class="language-py">data = await resource.read(...)
# ^-- This is a shortcut for the following --v
async with resource.stream(...) as reader:
    data = await reader.read()
</code></pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you simply wish to re-upload this resource to Discord via
any endpoint in Hikari, you should opt to just pass this
resource object directly. This way, Hikari can perform byte
inception, which significantly reduces the memory usage for
your bot as it grows larger.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to run in for blocking operations.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the default executor is used for the
current event loop.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>The entire resource.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.files.WebResource.stream" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="stream" href="#hikari.files.WebResource.stream" id="hikari.files.WebResource.stream">stream</a>(
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
    head_only: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> <a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.WebReader'>WebReader</a>]: ...</code></pre>
</dt>
<dd>
<p>Start streaming the content into memory by downloading it.</p>
<p>You can use this to fetch the entire resource, parts of the resource,
or just to view any metadata that may be provided.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>Not used. Provided only to match the underlying interface.</dd>
<dt><strong><code>head_only</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Defaults to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then the
implementation may only retrieve HEAD information if supported.
This currently only has any effect for web requests.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Downloading an entire resource at once into memory:</p>
<pre><code class="language-py">async with obj.stream() as stream:
    data = await stream.read()
</code></pre>
<p>Checking the metadata:</p>
<pre><code class="language-py">async with obj.stream() as stream:
    mimetype = stream.mimetype

if mimetype is None:
    ...
elif mimetype not in whitelisted_mimetypes:
    ...
else:
    ...
</code></pre>
<p>Fetching the data-uri of a resource:</p>
<pre><code class="language-py">async with obj.stream() as stream:
    data_uri = await stream.data_uri()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.files.AsyncReaderContextManager'>AsyncReaderContextManager</a>[<a href='#hikari.files.WebReader'>WebReader</a>]</code></dt>
<dd>An async context manager that when entered, produces the
data stream.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If a 400 is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If a 401 is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If a 403 is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If a 404 is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.ClientHTTPResponseError'>ClientHTTPResponseError</a></code></dt>
<dd>If any other 4xx is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If any other 5xx is returned.</dd>
<dt><code><a href='errors.html#hikari.errors.HTTPResponseError'>HTTPResponseError</a></code></dt>
<dd>If any other unexpected response code is returned.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/files.py#L646-L714" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def stream(
    self,
    *,
    executor: typing.Optional[concurrent.futures.Executor] = None,
    head_only: bool = False,
) -&gt; AsyncReaderContextManager[WebReader]:
    &#34;&#34;&#34;Start streaming the content into memory by downloading it.

    You can use this to fetch the entire resource, parts of the resource,
    or just to view any metadata that may be provided.

    Parameters
    ----------
    executor : typing.Optional[concurrent.futures.Executor]
        Not used. Provided only to match the underlying interface.
    head_only : builtins.bool
        Defaults to `builtins.False`. If `builtins.True`, then the
        implementation may only retrieve HEAD information if supported.
        This currently only has any effect for web requests.

    Examples
    --------
    Downloading an entire resource at once into memory:
    ```py
    async with obj.stream() as stream:
        data = await stream.read()
    ```
    Checking the metadata:
    ```py
    async with obj.stream() as stream:
        mimetype = stream.mimetype

    if mimetype is None:
        ...
    elif mimetype not in whitelisted_mimetypes:
        ...
    else:
        ...
    ```
    Fetching the data-uri of a resource:
    ```py
    async with obj.stream() as stream:
        data_uri = await stream.data_uri()
    ```

    Returns
    -------
    AsyncReaderContextManager[WebReader]
        An async context manager that when entered, produces the
        data stream.

    Raises
    ------
    hikari.errors.BadRequestError
        If a 400 is returned.
    hikari.errors.UnauthorizedError
        If a 401 is returned.
    hikari.errors.ForbiddenError
        If a 403 is returned.
    hikari.errors.NotFoundError
        If a 404 is returned.
    hikari.errors.ClientHTTPResponseError
        If any other 4xx is returned.
    hikari.errors.InternalServerError
        If any other 5xx is returned.
    hikari.errors.HTTPResponseError
        If any other unexpected response code is returned.
    &#34;&#34;&#34;
    return _WebReaderAsyncReaderContextManagerImpl(self, head_only)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>