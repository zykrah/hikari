<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.iterators API documentation</title>
<meta name="description" content="Lazy iterators for data that requires repeated API calls to retrieve …">
<meta property="og:title" content="hikari.iterators module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="index.html"
>hikari</a></li>
<li class="breadcrumb-item active"><a href="#">iterators</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Lazy iterators for data that requires repeated API calls to retrieve.</p>
<p>For consumers of this API, the only class you need to worry about is
<code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code>. Everything else is internal detail only exposed for people who
wish to extend this API further!</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard variable'>var</abbr></em></small> <a title="AnotherValueT -- Type-hint of the type of a value by a mapped lazy iterator." href="#hikari.iterators.AnotherValueT"
>AnotherValueT</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard variable'>var</abbr></em></small> <a title="ValueT -- Type-hint of the type of the value returned by a lazy iterator." href="#hikari.iterators.ValueT"
>ValueT</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="All -- Helper that wraps predicates and invokes them together …" href="#hikari.iterators.All"
>All</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="conditions -- Return an attribute of instance, which is of type owner." href="#hikari.iterators.All.conditions"
>conditions</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="AttrComparator -- A comparator that compares the result of a call with something else …" href="#hikari.iterators.AttrComparator"
>AttrComparator</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="attr_getter -- Return an attribute of instance, which is of type owner." href="#hikari.iterators.AttrComparator.attr_getter"
>attr_getter</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="cast -- Return an attribute of instance, which is of type owner." href="#hikari.iterators.AttrComparator.cast"
>cast</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="expected_value -- Return an attribute of instance, which is of type owner." href="#hikari.iterators.AttrComparator.expected_value"
>expected_value</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="BufferedLazyIterator -- A special kind of lazy iterator that is used by internal components …" href="#hikari.iterators.BufferedLazyIterator"
>BufferedLazyIterator</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="awaiting -- Await each item concurrently in a fixed size window …" href="#hikari.iterators.LazyIterator.awaiting"
>awaiting</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="#hikari.iterators.LazyIterator.chunk"
>chunk</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="collect -- Collect the results into a given type and return it …" href="#hikari.iterators.LazyIterator.collect"
>collect</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="count -- Count the number of results …" href="#hikari.iterators.LazyIterator.count"
>count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="enumerate -- Enumerate the paginated results lazily …" href="#hikari.iterators.LazyIterator.enumerate"
>enumerate</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="filter -- Filter the items by one or more conditions …" href="#hikari.iterators.LazyIterator.filter"
>filter</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="flat_map -- Perform a flat mapping operation …" href="#hikari.iterators.LazyIterator.flat_map"
>flat_map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="for_each -- Pass each value to a given consumer immediately." href="#hikari.iterators.LazyIterator.for_each"
>for_each</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="last -- Return the last element of this iterator only …" href="#hikari.iterators.LazyIterator.last"
>last</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="limit -- Limit the number of items you receive from this async iterator …" href="#hikari.iterators.LazyIterator.limit"
>limit</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="map -- Map the values to a different value …" href="#hikari.iterators.LazyIterator.map"
>map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="next -- Return the next element of this iterator only …" href="#hikari.iterators.LazyIterator.next"
>next</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="#hikari.iterators.LazyIterator.reversed"
>reversed</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip -- Drop the given number of items, then yield anything after …" href="#hikari.iterators.LazyIterator.skip"
>skip</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_until -- Discard items while all conditions are False …" href="#hikari.iterators.LazyIterator.skip_until"
>skip_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_while -- Discard items while all conditions are True …" href="#hikari.iterators.LazyIterator.skip_while"
>skip_while</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="sort -- Collect all results, then sort the collection before returning it." href="#hikari.iterators.LazyIterator.sort"
>sort</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_until -- Return each item until any conditions pass or the end is reached …" href="#hikari.iterators.LazyIterator.take_until"
>take_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_while -- Return each item until any conditions fail or the end is reached …" href="#hikari.iterators.LazyIterator.take_while"
>take_while</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="FlatLazyIterator -- A lazy iterator that has all items in-memory and ready …" href="#hikari.iterators.FlatLazyIterator"
>FlatLazyIterator</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="awaiting -- Await each item concurrently in a fixed size window …" href="#hikari.iterators.LazyIterator.awaiting"
>awaiting</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="#hikari.iterators.LazyIterator.chunk"
>chunk</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="collect -- Collect the results into a given type and return it …" href="#hikari.iterators.LazyIterator.collect"
>collect</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="count -- Count the number of results …" href="#hikari.iterators.LazyIterator.count"
>count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="enumerate -- Enumerate the paginated results lazily …" href="#hikari.iterators.LazyIterator.enumerate"
>enumerate</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="filter -- Filter the items by one or more conditions …" href="#hikari.iterators.LazyIterator.filter"
>filter</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="flat_map -- Perform a flat mapping operation …" href="#hikari.iterators.LazyIterator.flat_map"
>flat_map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="for_each -- Pass each value to a given consumer immediately." href="#hikari.iterators.LazyIterator.for_each"
>for_each</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="last -- Return the last element of this iterator only …" href="#hikari.iterators.LazyIterator.last"
>last</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="limit -- Limit the number of items you receive from this async iterator …" href="#hikari.iterators.LazyIterator.limit"
>limit</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="map -- Map the values to a different value …" href="#hikari.iterators.LazyIterator.map"
>map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="next -- Return the next element of this iterator only …" href="#hikari.iterators.LazyIterator.next"
>next</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="#hikari.iterators.LazyIterator.reversed"
>reversed</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip -- Drop the given number of items, then yield anything after …" href="#hikari.iterators.LazyIterator.skip"
>skip</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_until -- Discard items while all conditions are False …" href="#hikari.iterators.LazyIterator.skip_until"
>skip_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_while -- Discard items while all conditions are True …" href="#hikari.iterators.LazyIterator.skip_while"
>skip_while</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="sort -- Collect all results, then sort the collection before returning it." href="#hikari.iterators.LazyIterator.sort"
>sort</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_until -- Return each item until any conditions pass or the end is reached …" href="#hikari.iterators.LazyIterator.take_until"
>take_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_while -- Return each item until any conditions fail or the end is reached …" href="#hikari.iterators.LazyIterator.take_while"
>take_while</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="awaiting -- Await each item concurrently in a fixed size window …" href="#hikari.iterators.LazyIterator.awaiting"
>awaiting</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="#hikari.iterators.LazyIterator.chunk"
>chunk</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="collect -- Collect the results into a given type and return it …" href="#hikari.iterators.LazyIterator.collect"
>collect</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="count -- Count the number of results …" href="#hikari.iterators.LazyIterator.count"
>count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="enumerate -- Enumerate the paginated results lazily …" href="#hikari.iterators.LazyIterator.enumerate"
>enumerate</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="filter -- Filter the items by one or more conditions …" href="#hikari.iterators.LazyIterator.filter"
>filter</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="flat_map -- Perform a flat mapping operation …" href="#hikari.iterators.LazyIterator.flat_map"
>flat_map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="for_each -- Pass each value to a given consumer immediately." href="#hikari.iterators.LazyIterator.for_each"
>for_each</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="last -- Return the last element of this iterator only …" href="#hikari.iterators.LazyIterator.last"
>last</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="limit -- Limit the number of items you receive from this async iterator …" href="#hikari.iterators.LazyIterator.limit"
>limit</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="map -- Map the values to a different value …" href="#hikari.iterators.LazyIterator.map"
>map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="next -- Return the next element of this iterator only …" href="#hikari.iterators.LazyIterator.next"
>next</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="#hikari.iterators.LazyIterator.reversed"
>reversed</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip -- Drop the given number of items, then yield anything after …" href="#hikari.iterators.LazyIterator.skip"
>skip</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_until -- Discard items while all conditions are False …" href="#hikari.iterators.LazyIterator.skip_until"
>skip_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_while -- Discard items while all conditions are True …" href="#hikari.iterators.LazyIterator.skip_while"
>skip_while</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="sort -- Collect all results, then sort the collection before returning it." href="#hikari.iterators.LazyIterator.sort"
>sort</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_until -- Return each item until any conditions pass or the end is reached …" href="#hikari.iterators.LazyIterator.take_until"
>take_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_while -- Return each item until any conditions fail or the end is reached …" href="#hikari.iterators.LazyIterator.take_while"
>take_while</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L1-L1030" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Lazy iterators for data that requires repeated API calls to retrieve.

For consumers of this API, the only class you need to worry about is
`LazyIterator`. Everything else is internal detail only exposed for people who
wish to extend this API further!
&#34;&#34;&#34;
from __future__ import annotations

__all__: typing.List[str] = [
    &#34;LazyIterator&#34;,
    &#34;FlatLazyIterator&#34;,
    &#34;All&#34;,
    &#34;AttrComparator&#34;,
    &#34;BufferedLazyIterator&#34;,
    &#34;ValueT&#34;,
    &#34;AnotherValueT&#34;,
]

import abc
import asyncio
import typing

from hikari.internal import spel

ValueT = typing.TypeVar(&#34;ValueT&#34;)
&#34;&#34;&#34;Type-hint of the type of the value returned by a lazy iterator.&#34;&#34;&#34;
AnotherValueT = typing.TypeVar(&#34;AnotherValueT&#34;)
&#34;&#34;&#34;Type-hint of the type of a value by a mapped lazy iterator.&#34;&#34;&#34;


class All(typing.Generic[ValueT]):
    &#34;&#34;&#34;Helper that wraps predicates and invokes them together.

    Calling this object will pass the input item to each item, returning
    `builtins.True` only when all wrapped predicates return True when called
    with the given item.

    For example...

    ```py
    if w(foo) and x(foo) andy(foo) and z(foo):
        ...
    ```
    is equivalent to
    ```py
    condition = All([w, x, y, z])

    if condition(foo):
        ...
    ```

    This behaves like a lazy wrapper implementation of the `builtins.all` builtin.

    !!! note
        Like the rest of the standard library, this is a short-circuiting
        operation. This means that if a predicate returns `builtins.False`, no
        predicates after this are invoked, as the result is already known. In
        this sense, they are invoked in-order.

    !!! warning
        You should not generally need to use this outside of extending the
        iterators API in this library!

    Operators
    ---------
    * `this(value : ValueT) -&gt; bool`:
        Return `builtins.True` if all conditions return `builtins.True` when
        invoked with the given value.
    * `~this`:
        Return a condition that, when invoked with the value, returns
        `builtins.False` if all conditions were `builtins.True` in this object.

    Parameters
    ----------
    *conditions : typing.Callable[[ValueT], builtins.bool]
        The predicates to wrap.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;conditions&#34;,)

    def __init__(self, conditions: typing.Collection[typing.Callable[[ValueT], bool]]) -&gt; None:
        self.conditions = conditions

    def __bool__(self) -&gt; bool:
        return bool(self.conditions)

    def __call__(self, item: ValueT) -&gt; bool:
        return all(condition(item) for condition in self.conditions)

    def __invert__(self) -&gt; typing.Callable[[ValueT], bool]:
        return lambda item: not self(item)

    def __or__(self, other: All[ValueT]) -&gt; All[ValueT]:
        if not isinstance(other, All):
            raise TypeError(f&#34;unsupported operand type(s) for |: {type(self).__name__!r} and {type(other).__name__!r}&#34;)

        return All((self, other))


class AttrComparator(typing.Generic[ValueT]):
    &#34;&#34;&#34;A comparator that compares the result of a call with something else.

    This uses the `spel` module internally.

    Parameters
    ----------
    attr_name : builtins.str
        The attribute name. Can be prepended with a `.` optionally.
        If the attribute name ends with a `()`, then the call is invoked
        rather than treated as a property (useful for methods like
        `str.isupper`, for example).
    expected_value : typing.Any
        The expected value.
    cast : typing.Optional[typing.Callable[[ValueT], typing.Any]]
        Optional cast to perform on the input value when being called before
        comparing it to the expected value but after accessing the attribute.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;attr_getter&#34;, &#34;expected_value&#34;, &#34;cast&#34;)

    def __init__(
        self,
        attr_name: str,
        expected_value: typing.Any,
        cast: typing.Optional[typing.Callable[[ValueT], typing.Any]] = None,
    ) -&gt; None:
        self.expected_value = expected_value
        self.attr_getter: spel.AttrGetter[ValueT, typing.Any] = spel.AttrGetter(attr_name)
        self.cast = cast

    def __call__(self, item: ValueT) -&gt; bool:
        real_item = self.cast(self.attr_getter(item)) if self.cast is not None else self.attr_getter(item)
        return bool(real_item == self.expected_value)


class LazyIterator(typing.Generic[ValueT], abc.ABC):
    &#34;&#34;&#34;A set of results that are fetched asynchronously from the API as needed.

    This is a `typing.AsyncIterable` and `typing.AsyncIterator` with several
    additional helpful methods provided for convenience.

    Examples
    --------
    You can use this in multiple ways.

    As an async iterable:

    ```py
    &gt;&gt;&gt; async for item in paginated_results:
    ...    process(item)
    ```

    As an eagerly retrieved set of results (performs all API calls at once,
    which may be slow for large sets of data):

    ```py
    &gt;&gt;&gt; results = await paginated_results
    &gt;&gt;&gt; # ... which is equivalent to this...
    &gt;&gt;&gt; results = [item async for item in paginated_results]
    ```

    As an async iterator (not recommended):

    ```py
    &gt;&gt;&gt; try:
    ...    while True:
    ...        process(await paginated_results.__anext__())
    ... except StopAsyncIteration:
    ...    pass
    ```

    Additionally, you can make use of some of the provided helper methods
    on this class to perform basic operations easily.

    Iterating across the items with indexes (like `builtins.enumerate` for normal
    iterables):

    ```py
    &gt;&gt;&gt; async for i, item in paginated_results.enumerate():
    ...    print(i, item)
    (0, foo)
    (1, bar)
    (2, baz)
    ```

    Limiting the number of results you iterate across:

    ```py
    &gt;&gt;&gt; async for item in paginated_results.limit(3):
    ...    process(item)
    ```
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def chunk(self, chunk_size: int) -&gt; LazyIterator[typing.Sequence[ValueT]]:
        &#34;&#34;&#34;Return results in chunks of up to `chunk_size` amount of entries.

        Parameters
        ----------
        chunk_size : int
            The limit for how many results should be returned in each chunk.

        Returns
        -------
        LazyIterator[typing.Sequence[ValueT]]
            `LazyIterator` that emits each chunked sequence.
        &#34;&#34;&#34;
        return _ChunkedLazyIterator(self, chunk_size)

    def map(
        self,
        transformation: typing.Union[typing.Callable[[ValueT], AnotherValueT], str],
    ) -&gt; LazyIterator[AnotherValueT]:
        &#34;&#34;&#34;Map the values to a different value.

        Parameters
        ----------
        transformation : typing.Union[typing.Callable[[ValueT], builtins.bool], builtins.str]
            The function to use to map the attribute. This may alternatively
            be a string attribute name to replace the input value with. You
            can provide nested attributes using the `.` operator.

        Returns
        -------
        LazyIterator[AnotherValueT]
            `LazyIterator` that maps each value to another value.
        &#34;&#34;&#34;
        if isinstance(transformation, str):
            transformation = typing.cast(&#34;spel.AttrGetter[ValueT, AnotherValueT]&#34;, spel.AttrGetter(transformation))

        return _MappingLazyIterator(self, transformation)

    async def for_each(self, consumer: typing.Callable[[ValueT], typing.Any]) -&gt; None:
        &#34;&#34;&#34;Pass each value to a given consumer immediately.&#34;&#34;&#34;
        if asyncio.iscoroutinefunction(consumer):
            async for item in self:
                await consumer(item)
        else:
            async for item in self:
                consumer(item)

    def filter(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Filter the items by one or more conditions.

        Each condition is treated as a predicate, being called with each item
        that this iterator would return when it is requested.

        All conditions must evaluate to `builtins.True` for the item to be
        returned. If this is not met, then the item is discarded and ignored,
        the next matching item will be returned instead, if there is one.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes
            are referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.filter((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            `LazyIterator` that only emits values where all conditions are
            matched.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;filter&#34;, *predicates, **attrs)
        return _FilteredLazyIterator(self, conditions)

    def take_while(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Return each item until any conditions fail or the end is reached.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes
            are referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.take_while((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            LazyIterator that only emits values until any conditions are not
            matched.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;take_while&#34;, *predicates, **attrs)
        return _TakeWhileLazyIterator(self, conditions)

    def take_until(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Return each item until any conditions pass or the end is reached.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes are
            referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.take_until((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            LazyIterator that only emits values until any conditions are
            matched.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;take_until&#34;, *predicates, **attrs)
        return _TakeWhileLazyIterator(self, ~conditions)

    def skip_while(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Discard items while all conditions are True.

        Items after this will be yielded as normal.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes
            are referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.skip_while((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            LazyIterator that only emits values once a condition has been met.
            All items before this are discarded.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;skip_while&#34;, *predicates, **attrs)
        return _DropWhileLazyIterator(self, conditions)

    def skip_until(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Discard items while all conditions are False.

        Items after this will be yielded as normal.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes are
            referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.skip_until((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            LazyIterator that only emits values once a condition has failed.
            All items before this are discarded.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;skip_until&#34;, *predicates, **attrs)
        return _DropWhileLazyIterator(self, ~conditions)

    def enumerate(self, *, start: int = 0) -&gt; LazyIterator[typing.Tuple[int, ValueT]]:
        &#34;&#34;&#34;Enumerate the paginated results lazily.

        This behaves as an asyncio-friendly version of `builtins.enumerate`
        which uses much less memory than collecting all the results first and
        calling `builtins.enumerate` across them.

        Parameters
        ----------
        start : builtins.int
            Optional int to start at. If omitted, this is `0`.

        Examples
        --------
            &gt;&gt;&gt; async for i, item in paginated_results.enumerate():
            ...    print(i, item)
            (0, foo)
            (1, bar)
            (2, baz)
            (3, bork)
            (4, qux)

            &gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9):
            ...    print(i, item)
            (9, foo)
            (10, bar)
            (11, baz)
            (12, bork)
            (13, qux)

            &gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9).limit(3):
            ...    print(i, item)
            (9, foo)
            (10, bar)
            (11, baz)

        Returns
        -------
        LazyIterator[typing.Tuple[builtins.int, T]]
            A paginated results view that asynchronously yields an increasing
            counter in a tuple with each result, lazily.
        &#34;&#34;&#34;
        return _EnumeratedLazyIterator(self, start=start)

    def limit(self, limit: int) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Limit the number of items you receive from this async iterator.

        Parameters
        ----------
        limit : builtins.int
            The number of items to get. This must be greater than zero.

        Examples
        --------
            &gt;&gt;&gt; async for item in paginated_results.limit(3):
            ...     print(item)

        Returns
        -------
        LazyIterator[ValueT]
            A paginated results view that asynchronously yields a maximum
            of the given number of items before completing.
        &#34;&#34;&#34;
        return _LimitedLazyIterator(self, limit)

    def skip(self, number: int) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Drop the given number of items, then yield anything after.

        Parameters
        ----------
        number : builtins.int
            The max number of items to drop before any items are yielded.

        Returns
        -------
        LazyIterator[ValueT]
            A paginated results view that asynchronously yields all items
            AFTER the given number of items are discarded first.
        &#34;&#34;&#34;
        return _DropCountLazyIterator(self, number)

    async def next(self) -&gt; ValueT:
        &#34;&#34;&#34;Return the next element of this iterator only.

        Returns
        -------
        ValueT
            The next result.

        Raises
        ------
        builtins.LookupError
            If no more results exist.
        &#34;&#34;&#34;
        try:
            return await self.__anext__()
        except StopAsyncIteration:
            raise LookupError(&#34;No elements were found&#34;) from None

    async def last(self) -&gt; ValueT:
        &#34;&#34;&#34;Return the last element of this iterator only.

        Returns
        -------
        ValueT
            The last result.

        !!! note
            This method will consume the whole iterator if run.

        Raises
        ------
        builtins.LookupError
            If no result exists.
        &#34;&#34;&#34;
        return await self.reversed().next()

    def reversed(self) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Return a lazy iterator of the remainder of this iterator&#39;s values reversed.

        Returns
        -------
        LazyIterator[ValueT]
            The lazy iterator of this iterator&#39;s remaining values reversed.
        &#34;&#34;&#34;
        return _ReversedLazyIterator(self)

    async def sort(self, *, key: typing.Any = None, reverse: bool = False) -&gt; typing.Sequence[ValueT]:
        &#34;&#34;&#34;Collect all results, then sort the collection before returning it.&#34;&#34;&#34;
        return sorted(await self, key=key, reverse=reverse)

    async def collect(
        self, collector: typing.Callable[[typing.Sequence[ValueT]], typing.Collection[ValueT]]
    ) -&gt; typing.Collection[ValueT]:
        &#34;&#34;&#34;Collect the results into a given type and return it.

        Parameters
        ----------
        collector
            A function that consumes a sequence of values and returns a
            collection.
        &#34;&#34;&#34;
        return collector(await self)

    async def count(self) -&gt; int:
        &#34;&#34;&#34;Count the number of results.

        Returns
        -------
        builtins.int
            Number of results found.
        &#34;&#34;&#34;
        count = 0
        async for _ in self:
            count += 1

        return count

    def flat_map(self, flattener: _FlattenerT[ValueT, AnotherValueT]) -&gt; LazyIterator[AnotherValueT]:
        r&#34;&#34;&#34;Perform a flat mapping operation.

        This will pass each item in the iterator to the given `function`
        parameter, expecting a new `typing.Iterable` or `typing.AsyncIterator`
        to be returned as the result. This means you can map to a new
        `LazyIterator`, `typing.AsyncIterator`, `typing.Iterable`,
        async generator, or generator.

        Remember that `typing.Iterator` implicitly provides `typing.Iterable`
        compatibility.

        This is used to provide lazy conversions, and can be used to implement
        reactive-like pipelines if desired.

        All results are combined into one large lazy iterator and yielded
        lazily.

        Parameters
        ----------
        flattener
            A function that returns either an async iterator or iterator of
            new values. Could be an attribute name instead.

        Example
        -------

        The following example generates a distinct collection of all mentioned
        users in the given channel from the past 500 messages.

        ```py
        def iter_mentioned_users(message: hikari.Message) -&gt; typing.Iterable[Snowflake]:
            for match in re.findall(r&#34;&lt;@!?(\d+)&gt;&#34;, message.content):
                yield Snowflake(match)

        mentioned_users = await (
            channel
            .history()
            .limit(500)
            .map(&#34;.content&#34;)
            .flat_map(iter_mentioned_users)
            .distinct()
        )
        ```

        Returns
        -------
        LazyIterator[AnotherValueT]
            The new lazy iterator to return.
        &#34;&#34;&#34;
        return _FlatMapLazyIterator(self, flattener)

    def awaiting(self, window_size: int = 10) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Await each item concurrently in a fixed size window.

        Parameters
        ----------
        window_size : int
            The window size of how many tasks to await at once. You can set this
            to `0` to await everything at once, but see the below warning.

        Returns
        -------
        LazyIterator[ValueT]
            The new lazy iterator to return.

        !!! warning
            Setting a large window size, or setting it to 0 to await everything
            is a dangerous thing to do if you are making API calls. Some
            endpoints will get ratelimited and cause a backup of waiting
            tasks, others may begin to spam global rate limits instead
            (the `fetch_user` endpoint seems to be notorious for doing this).

        !!! note
            This call assumes that the iterator contains awaitable values as
            input. MyPy cannot detect this nicely, so any cast is forced
            internally.

            If the item is not awaitable, you will receive a
            `builtins.TypeError` instead.

            You have been warned. You cannot escape the ways of the duck type
            young grasshopper.
        &#34;&#34;&#34;
        # Not type safe. Can I make this type safe?
        return _AwaitingLazyIterator(typing.cast(&#34;LazyIterator[typing.Awaitable[ValueT]]&#34;, self), window_size)

    @staticmethod
    def _map_predicates_and_attr_getters(
        alg_name: str,
        *predicates: typing.Union[str, typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; All[ValueT]:
        if not predicates and not attrs:
            raise TypeError(f&#34;You should provide at least one predicate to {alg_name}()&#34;)

        conditions: typing.List[typing.Callable[[ValueT], bool]] = []

        for p in predicates:
            if isinstance(p, tuple):
                name, value = p
                tuple_comparator: AttrComparator[ValueT] = AttrComparator(name, value)
                conditions.append(tuple_comparator)
            elif isinstance(p, str):
                comparator: AttrComparator[ValueT] = AttrComparator(p, True, bool)
                conditions.append(comparator)
            else:
                conditions.append(p)

        for name, value in attrs.items():
            attr_comparator: AttrComparator[ValueT] = AttrComparator(name, value)
            conditions.append(attr_comparator)

        return All(conditions)

    def _complete(self) -&gt; typing.NoReturn:
        raise StopAsyncIteration(&#34;No more items exist in this iterator. It has been exhausted.&#34;) from None

    def __aiter__(self) -&gt; LazyIterator[ValueT]:
        # We are our own async iterator.
        return self

    def __iter__(self) -&gt; LazyIterator[ValueT]:
        # This iterator is async only.
        cls = type(self)
        raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is an async-only iterator, did you mean &#39;async for&#39;?&#34;)

    async def _fetch_all(self) -&gt; typing.Sequence[ValueT]:
        return [item async for item in self]

    def __await__(self) -&gt; typing.Generator[None, None, typing.Sequence[ValueT]]:
        return self._fetch_all().__await__()

    @abc.abstractmethod
    async def __anext__(self) -&gt; ValueT:
        ...


class BufferedLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT], abc.ABC):
    &#34;&#34;&#34;A special kind of lazy iterator that is used by internal components.

    The purpose of this is to provide an interface to lazily deserialize
    collections of payloads received from paginated API endpoints such as
    `GET /channels/{channel_id}/messages`, which will return a certain number
    of messages at a time on a low level. This class provides the base interface
    for handling lazily decoding each item in those responses and returning them
    in the expected format when iterating across this object.

    Implementations are expected to provide a `_next_chunk` private method
    which when awaited returns a lazy generator of each deserialized object
    to later yield. This will be iterated across lazily by this implementation,
    thus reducing the amount of work needed if only a few objects out of, say,
    100, need to be deserialized.

    This `_next_chunk` should return `builtins.None` once the end of all items
    has been reached.

    An example would look like the following:

    ```py
    async def some_http_call(i):
        ...


    class SomeEndpointLazyIterator(BufferedLazyIterator[SomeObject]):
        def __init__(self):
            super().__init__()
            self._i = 0


        def _next_chunk(self) -&gt; typing.Optional[typing.Generator[ValueT, None, None]]:
            raw_items = await some_http_call(self._i)
            self._i += 1

            if not raw_items:
                return None

            generator = (SomeObject(raw_item) for raw_item in raw_items)
            return generator
    ```
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_buffer&#34;,)

    def __init__(self) -&gt; None:
        self._buffer: typing.Optional[typing.Generator[ValueT, None, None]] = (_ for _ in ())

    @abc.abstractmethod
    async def _next_chunk(self) -&gt; typing.Optional[typing.Generator[ValueT, None, None]]:
        ...

    async def __anext__(self) -&gt; ValueT:
        # This sneaky snippet of code lets us use generators rather than lists.
        # This is important, as we can use this to make generators that
        # deserialize loads of items lazy. If we only want 10 messages of
        # history, we can use the same code and prefetch 100 without any
        # performance hit from it other than the JSON string response.
        try:
            if self._buffer is not None:
                return next(self._buffer)
        except StopIteration:
            self._buffer = await self._next_chunk()
            if self._buffer is not None:
                return next(self._buffer)
        self._complete()


class FlatLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    &#34;&#34;&#34;A lazy iterator that has all items in-memory and ready.

    This can be iterated across as a normal iterator, or as an async iterator.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_iter&#34;,)

    def __init__(self, values: typing.Iterable[ValueT]) -&gt; None:
        self._iter = iter(values)

    def __iter__(self) -&gt; FlatLazyIterator[ValueT]:
        return self

    def __next__(self) -&gt; ValueT:
        return next(self._iter)

    async def __anext__(self) -&gt; ValueT:
        try:
            return next(self._iter)
        except StopIteration:
            self._complete()


class _EnumeratedLazyIterator(typing.Generic[ValueT], LazyIterator[typing.Tuple[int, ValueT]]):
    __slots__: typing.Sequence[str] = (&#34;_i&#34;, &#34;_iterator&#34;)

    def __init__(self, iterator: LazyIterator[ValueT], *, start: int) -&gt; None:
        self._i = start
        self._iterator = iterator

    async def __anext__(self) -&gt; typing.Tuple[int, ValueT]:
        pair = self._i, await self._iterator.__anext__()
        self._i += 1
        return pair


class _LimitedLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_count&#34;, &#34;_limit&#34;)

    def __init__(self, iterator: LazyIterator[ValueT], limit: int) -&gt; None:
        if limit &lt;= 0:
            raise ValueError(&#34;limit must be positive and non-zero&#34;)
        self._iterator = iterator
        self._count = 0
        self._limit = limit

    async def __anext__(self) -&gt; ValueT:
        if self._count &gt;= self._limit:
            self._complete()

        next_item = await self._iterator.__anext__()
        self._count += 1
        return next_item


class _DropCountLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_count&#34;, &#34;_number&#34;)

    def __init__(self, iterator: LazyIterator[ValueT], number: int) -&gt; None:
        if number &lt;= 0:
            raise ValueError(&#34;number must be positive and non-zero&#34;)
        self._iterator = iterator
        self._count = 0
        self._number = number

    async def __anext__(self) -&gt; ValueT:
        while self._count &lt; self._number:
            self._count += 1
            await self._iterator.__anext__()

        next_item = await self._iterator.__anext__()
        return next_item


class _FilteredLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_predicate&#34;)

    def __init__(self, iterator: LazyIterator[ValueT], predicate: typing.Callable[[ValueT], bool]) -&gt; None:
        self._iterator = iterator
        self._predicate = predicate

    async def __anext__(self) -&gt; ValueT:
        async for item in self._iterator:
            if self._predicate(item):
                return item

        self._complete()


class _ChunkedLazyIterator(typing.Generic[ValueT], LazyIterator[typing.Sequence[ValueT]]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_chunk_size&#34;)

    def __init__(self, iterator: LazyIterator[ValueT], chunk_size: int) -&gt; None:
        self._iterator = iterator
        self._chunk_size = chunk_size

    async def __anext__(self) -&gt; typing.Sequence[ValueT]:
        chunk = []

        async for item in self._iterator:
            chunk.append(item)

            if len(chunk) == self._chunk_size:
                break

        if chunk:
            return chunk

        self._complete()


class _ReversedLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    __slots__: typing.Sequence[str] = (&#34;_buffer&#34;, &#34;_origin&#34;)

    def __init__(self, iterator: LazyIterator[ValueT]) -&gt; None:
        self._buffer: typing.MutableSequence[ValueT] = []
        self._origin: typing.Optional[LazyIterator[ValueT]] = iterator

    async def __anext__(self) -&gt; ValueT:
        if self._origin is not None:
            self._buffer.extend(await self._origin)
            self._origin = None

        try:
            return self._buffer.pop()
        except IndexError:
            self._complete()


class _MappingLazyIterator(typing.Generic[AnotherValueT, ValueT], LazyIterator[ValueT]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_transformation&#34;)

    def __init__(
        self,
        iterator: LazyIterator[AnotherValueT],
        transformation: typing.Callable[[AnotherValueT], ValueT],
    ) -&gt; None:
        self._iterator = iterator
        self._transformation = transformation

    async def __anext__(self) -&gt; ValueT:
        return self._transformation(await self._iterator.__anext__())


class _TakeWhileLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_condition&#34;)

    def __init__(self, iterator: LazyIterator[ValueT], condition: typing.Callable[[ValueT], bool]) -&gt; None:
        self._iterator = iterator
        self._condition = condition

    async def __anext__(self) -&gt; ValueT:
        item = await self._iterator.__anext__()

        if self._condition(item):
            return item

        self._complete()


class _DropWhileLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_condition&#34;, &#34;_has_dropped&#34;)

    def __init__(self, iterator: LazyIterator[ValueT], condition: typing.Callable[[ValueT], bool]) -&gt; None:
        self._iterator = iterator
        self._condition = condition
        self._has_dropped = False

    async def __anext__(self) -&gt; ValueT:
        if not self._has_dropped:
            while not self._condition(item := await self._iterator.__anext__()):
                pass

            self._has_dropped = True
            return item

        return await self._iterator.__anext__()


_FlattenerResultT = typing.Union[typing.AsyncIterator[AnotherValueT], typing.Iterable[AnotherValueT]]

_FlattenerT = typing.Union[
    spel.AttrGetter[ValueT, _FlattenerResultT[AnotherValueT]],
    typing.Callable[[ValueT], _FlattenerResultT[AnotherValueT]],
]


class _FlatMapLazyIterator(typing.Generic[ValueT, AnotherValueT], LazyIterator[AnotherValueT]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_flattener&#34;, &#34;_result_iterator&#34;)

    def __init__(self, iterator: LazyIterator[ValueT], flattener: _FlattenerT[ValueT, AnotherValueT]) -&gt; None:
        self._iterator = iterator
        self._flattener = flattener
        self._result_iterator: typing.Optional[typing.AsyncIterator[AnotherValueT]] = None

    async def _generator(self) -&gt; typing.AsyncIterator[AnotherValueT]:
        async for input_item in self._iterator:
            result_iterator = self._flattener(input_item)

            # Turns out that Iterator is also Iterable, interestingly.
            if isinstance(result_iterator, typing.Iterable):
                for output_item in result_iterator:
                    yield output_item
            else:
                async for output_item in result_iterator:
                    yield output_item

    async def __anext__(self) -&gt; AnotherValueT:
        if self._result_iterator is None:
            self._result_iterator = self._generator()

        return await self._result_iterator.__anext__()


class _AwaitingLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    __slots__: typing.Sequence[str] = (&#34;_iterator&#34;, &#34;_window_size&#34;, &#34;_buffer&#34;)

    def __init__(self, iterator: LazyIterator[typing.Awaitable[ValueT]], window_size: int) -&gt; None:
        self._iterator = iterator
        self._window_size = float(&#34;inf&#34;) if window_size &lt;= 0 else window_size
        self._buffer: typing.List[ValueT] = []

    async def __anext__(self) -&gt; ValueT:
        if not self._buffer:
            coroutines: typing.List[typing.Awaitable[ValueT]] = []

            while len(coroutines) &lt; self._window_size:
                try:
                    next_coroutine = await self._iterator.__anext__()
                    coroutines.append(next_coroutine)
                except StopAsyncIteration:
                    break

            if not coroutines:
                raise StopAsyncIteration

            self._buffer.extend(await asyncio.gather(*coroutines))

        return self._buffer.pop(0)</code></pre>
</details>
</div>
</div>
<h2 id="variables-heading">Variables and Type Hints</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.iterators.AnotherValueT" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A standard variable'>var</abbr></em></small> <a title="AnotherValueT -- Type-hint of the type of a value by a mapped lazy iterator." href="#hikari.iterators.AnotherValueT"  >AnotherValueT</a></code></pre>
</dt>
<dd><p>Type-hint of the type of a value by a mapped lazy iterator.</p></dd>
</div>
<div id="hikari.iterators.ValueT" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A standard variable'>var</abbr></em></small> <a title="ValueT -- Type-hint of the type of the value returned by a lazy iterator." href="#hikari.iterators.ValueT"  >ValueT</a></code></pre>
</dt>
<dd><p>Type-hint of the type of the value returned by a lazy iterator.</p></dd>
</div>
</dl>
</section>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.iterators.All" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="All -- Helper that wraps predicates and invokes them together …" href="#hikari.iterators.All"
>All</a></h4>
</dt>
<dd>
<pre><code id="hikari.iterators.All" class="hljs python"><abbr title='A standard Python type.'>class</abbr> All (
    conditions: <a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
): ...</code></pre>
<p>Helper that wraps predicates and invokes them together.</p>
<p>Calling this object will pass the input item to each item, returning
<code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> only when all wrapped predicates return True when called
with the given item.</p>
<p>For example&hellip;</p>
<pre><code class="language-py">if w(foo) and x(foo) andy(foo) and z(foo):
    ...
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-py">condition = All([w, x, y, z])

if condition(foo):
    ...
</code></pre>
<p>This behaves like a lazy wrapper implementation of the <code><a href='https://docs.python.org/3/library/functions.html#all'>all</a></code> builtin.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Like the rest of the standard library, this is a short-circuiting
operation. This means that if a predicate returns <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no
predicates after this are invoked, as the result is already known. In
this sense, they are invoked in-order.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>You should not generally need to use this outside of extending the
iterators API in this library!</p>
</div>
<h2 id="operators">Operators</h2>
<ul>
<li><code>this(value : <a href='#hikari.iterators.ValueT'>ValueT</a>) -&gt; <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code>:
Return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if all conditions return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> when
invoked with the given value.</li>
<li><code>~this</code>:
Return a condition that, when invoked with the value, returns
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> if all conditions were <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> in this object.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*conditions</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>The predicates to wrap.</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L53-L119" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class All(typing.Generic[ValueT]):
    &#34;&#34;&#34;Helper that wraps predicates and invokes them together.

    Calling this object will pass the input item to each item, returning
    `builtins.True` only when all wrapped predicates return True when called
    with the given item.

    For example...

    ```py
    if w(foo) and x(foo) andy(foo) and z(foo):
        ...
    ```
    is equivalent to
    ```py
    condition = All([w, x, y, z])

    if condition(foo):
        ...
    ```

    This behaves like a lazy wrapper implementation of the `builtins.all` builtin.

    !!! note
        Like the rest of the standard library, this is a short-circuiting
        operation. This means that if a predicate returns `builtins.False`, no
        predicates after this are invoked, as the result is already known. In
        this sense, they are invoked in-order.

    !!! warning
        You should not generally need to use this outside of extending the
        iterators API in this library!

    Operators
    ---------
    * `this(value : ValueT) -&gt; bool`:
        Return `builtins.True` if all conditions return `builtins.True` when
        invoked with the given value.
    * `~this`:
        Return a condition that, when invoked with the value, returns
        `builtins.False` if all conditions were `builtins.True` in this object.

    Parameters
    ----------
    *conditions : typing.Callable[[ValueT], builtins.bool]
        The predicates to wrap.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;conditions&#34;,)

    def __init__(self, conditions: typing.Collection[typing.Callable[[ValueT], bool]]) -&gt; None:
        self.conditions = conditions

    def __bool__(self) -&gt; bool:
        return bool(self.conditions)

    def __call__(self, item: ValueT) -&gt; bool:
        return all(condition(item) for condition in self.conditions)

    def __invert__(self) -&gt; typing.Callable[[ValueT], bool]:
        return lambda item: not self(item)

    def __or__(self, other: All[ValueT]) -&gt; All[ValueT]:
        if not isinstance(other, All):
            raise TypeError(f&#34;unsupported operand type(s) for |: {type(self).__name__!r} and {type(other).__name__!r}&#34;)

        return All((self, other))</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="All -- Helper that wraps predicates and invokes them together …" href="#hikari.iterators.All"
>All</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.iterators.All.conditions" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="conditions -- Return an attribute of instance, which is of type owner." href="#hikari.iterators.All.conditions"  >conditions</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
</div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.iterators.AttrComparator" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="AttrComparator -- A comparator that compares the result of a call with something else …" href="#hikari.iterators.AttrComparator"
>AttrComparator</a></h4>
</dt>
<dd>
<pre><code id="hikari.iterators.AttrComparator" class="hljs python"><abbr title='A standard Python type.'>class</abbr> AttrComparator (
    attr_name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    expected_value: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
    cast: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]] = None,
): ...</code></pre>
<p>A comparator that compares the result of a call with something else.</p>
<p>This uses the <code>spel</code> module internally.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>attr_name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The attribute name. Can be prepended with a <code>.</code> optionally.
If the attribute name ends with a <code>()</code>, then the call is invoked
rather than treated as a property (useful for methods like
<code><a href='https://docs.python.org/3/library/stdtypes.html#str.isupper'>str.isupper</a></code>, for example).</dd>
<dt><strong><code>expected_value</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>The expected value.</dd>
<dt><strong><code>cast</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Optional cast to perform on the input value when being called before
comparing it to the expected value but after accessing the attribute.</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L122-L155" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class AttrComparator(typing.Generic[ValueT]):
    &#34;&#34;&#34;A comparator that compares the result of a call with something else.

    This uses the `spel` module internally.

    Parameters
    ----------
    attr_name : builtins.str
        The attribute name. Can be prepended with a `.` optionally.
        If the attribute name ends with a `()`, then the call is invoked
        rather than treated as a property (useful for methods like
        `str.isupper`, for example).
    expected_value : typing.Any
        The expected value.
    cast : typing.Optional[typing.Callable[[ValueT], typing.Any]]
        Optional cast to perform on the input value when being called before
        comparing it to the expected value but after accessing the attribute.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;attr_getter&#34;, &#34;expected_value&#34;, &#34;cast&#34;)

    def __init__(
        self,
        attr_name: str,
        expected_value: typing.Any,
        cast: typing.Optional[typing.Callable[[ValueT], typing.Any]] = None,
    ) -&gt; None:
        self.expected_value = expected_value
        self.attr_getter: spel.AttrGetter[ValueT, typing.Any] = spel.AttrGetter(attr_name)
        self.cast = cast

    def __call__(self, item: ValueT) -&gt; bool:
        real_item = self.cast(self.attr_getter(item)) if self.cast is not None else self.attr_getter(item)
        return bool(real_item == self.expected_value)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="AttrComparator -- A comparator that compares the result of a call with something else …" href="#hikari.iterators.AttrComparator"
>AttrComparator</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.iterators.AttrComparator.attr_getter" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="attr_getter -- Return an attribute of instance, which is of type owner." href="#hikari.iterators.AttrComparator.attr_getter"  >attr_getter</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
</div>
<div id="hikari.iterators.AttrComparator.cast" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="cast -- Return an attribute of instance, which is of type owner." href="#hikari.iterators.AttrComparator.cast"  >cast</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
</div>
<div id="hikari.iterators.AttrComparator.expected_value" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="expected_value -- Return an attribute of instance, which is of type owner." href="#hikari.iterators.AttrComparator.expected_value"  >expected_value</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
</div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.iterators.BufferedLazyIterator" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="BufferedLazyIterator -- A special kind of lazy iterator that is used by internal components …" href="#hikari.iterators.BufferedLazyIterator"
>BufferedLazyIterator</a></h4>
</dt>
<dd>
<pre><code id="hikari.iterators.BufferedLazyIterator" class="hljs python"><abbr title='A standard Python type.'>class</abbr> BufferedLazyIterator: ...</code></pre>
<p>A special kind of lazy iterator that is used by internal components.</p>
<p>The purpose of this is to provide an interface to lazily deserialize
collections of payloads received from paginated API endpoints such as
<code>GET /channels/{channel_id}/messages</code>, which will return a certain number
of messages at a time on a low level. This class provides the base interface
for handling lazily decoding each item in those responses and returning them
in the expected format when iterating across this object.</p>
<p>Implementations are expected to provide a <code>_next_chunk</code> private method
which when awaited returns a lazy generator of each deserialized object
to later yield. This will be iterated across lazily by this implementation,
thus reducing the amount of work needed if only a few objects out of, say,
100, need to be deserialized.</p>
<p>This <code>_next_chunk</code> should return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> once the end of all items
has been reached.</p>
<p>An example would look like the following:</p>
<pre><code class="language-py">async def some_http_call(i):
    ...


class SomeEndpointLazyIterator(BufferedLazyIterator[SomeObject]):
    def __init__(self):
        super().__init__()
        self._i = 0


    def _next_chunk(self) -&gt; typing.Optional[typing.Generator[ValueT, None, None]]:
        raw_items = await some_http_call(self._i)
        self._i += 1

        if not raw_items:
            return None

        generator = (SomeObject(raw_item) for raw_item in raw_items)
        return generator
</code></pre>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L722-L788" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class BufferedLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT], abc.ABC):
    &#34;&#34;&#34;A special kind of lazy iterator that is used by internal components.

    The purpose of this is to provide an interface to lazily deserialize
    collections of payloads received from paginated API endpoints such as
    `GET /channels/{channel_id}/messages`, which will return a certain number
    of messages at a time on a low level. This class provides the base interface
    for handling lazily decoding each item in those responses and returning them
    in the expected format when iterating across this object.

    Implementations are expected to provide a `_next_chunk` private method
    which when awaited returns a lazy generator of each deserialized object
    to later yield. This will be iterated across lazily by this implementation,
    thus reducing the amount of work needed if only a few objects out of, say,
    100, need to be deserialized.

    This `_next_chunk` should return `builtins.None` once the end of all items
    has been reached.

    An example would look like the following:

    ```py
    async def some_http_call(i):
        ...


    class SomeEndpointLazyIterator(BufferedLazyIterator[SomeObject]):
        def __init__(self):
            super().__init__()
            self._i = 0


        def _next_chunk(self) -&gt; typing.Optional[typing.Generator[ValueT, None, None]]:
            raw_items = await some_http_call(self._i)
            self._i += 1

            if not raw_items:
                return None

            generator = (SomeObject(raw_item) for raw_item in raw_items)
            return generator
    ```
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_buffer&#34;,)

    def __init__(self) -&gt; None:
        self._buffer: typing.Optional[typing.Generator[ValueT, None, None]] = (_ for _ in ())

    @abc.abstractmethod
    async def _next_chunk(self) -&gt; typing.Optional[typing.Generator[ValueT, None, None]]:
        ...

    async def __anext__(self) -&gt; ValueT:
        # This sneaky snippet of code lets us use generators rather than lists.
        # This is important, as we can use this to make generators that
        # deserialize loads of items lazy. If we only want 10 messages of
        # history, we can use the same code and prefetch 100 without any
        # performance hit from it other than the JSON string response.
        try:
            if self._buffer is not None:
                return next(self._buffer)
        except StopIteration:
            self._buffer = await self._next_chunk()
            if self._buffer is not None:
                return next(self._buffer)
        self._complete()</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="BufferedLazyIterator -- A special kind of lazy iterator that is used by internal components …" href="#hikari.iterators.BufferedLazyIterator"
>BufferedLazyIterator</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></dt>
<dd class="nested"><p>A set of results that are fetched asynchronously from the API as needed …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.iterators.BufferedLazyIterator.awaiting" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="awaiting" href="#hikari.iterators.LazyIterator.awaiting" id="hikari.iterators.BufferedLazyIterator.awaiting">awaiting</a>(
    window_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 10,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="awaiting -- Await each item concurrently in a fixed size window …" href="#hikari.iterators.LazyIterator.awaiting"
>awaiting</a></code>
</p>
<p>Await each item concurrently in a fixed size window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>window_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The window size of how many tasks to await at once. You can set this
to <code>0</code> to await everything at once, but see the below warning.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Setting a large window size, or setting it to 0 to await everything
is a dangerous thing to do if you are making API calls. Some
endpoints will get ratelimited and cause a backup of waiting
tasks, others may begin to spam global rate limits instead
(the <code>fetch_user</code> endpoint seems to be notorious for doing this).</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call assumes that the iterator contains awaitable values as
input. MyPy cannot detect this nicely, so any cast is forced
internally.</p>
<p>If the item is not awaitable, you will receive a
<code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code> instead.</p>
<p>You have been warned. You cannot escape the ways of the duck type
young grasshopper.</p>
</div>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.chunk" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="chunk" href="#hikari.iterators.LazyIterator.chunk" id="hikari.iterators.BufferedLazyIterator.chunk">chunk</a>(
    chunk_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="#hikari.iterators.LazyIterator.chunk"
>chunk</a></code>
</p>
<p>Return results in chunks of up to <code>chunk_size</code> amount of entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chunk_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The limit for how many results should be returned in each chunk.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that emits each chunked sequence.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.collect" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="collect" href="#hikari.iterators.LazyIterator.collect" id="hikari.iterators.BufferedLazyIterator.collect">collect</a>(
    collector: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]], <a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]],
) -> Collection[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="collect -- Collect the results into a given type and return it …" href="#hikari.iterators.LazyIterator.collect"
>collect</a></code>
</p>
<p>Collect the results into a given type and return it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>collector</code></strong></dt>
<dd>A function that consumes a sequence of values and returns a
collection.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.count" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="count" href="#hikari.iterators.LazyIterator.count" id="hikari.iterators.BufferedLazyIterator.count">count</a>() -> <a href='https://docs.python.org/3/library/functions.html#int'>int</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="count -- Count the number of results …" href="#hikari.iterators.LazyIterator.count"
>count</a></code>
</p>
<p>Count the number of results.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Number of results found.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.enumerate" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="enumerate" href="#hikari.iterators.LazyIterator.enumerate" id="hikari.iterators.BufferedLazyIterator.enumerate">enumerate</a>(
    *,
    start: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, ~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="enumerate -- Enumerate the paginated results lazily …" href="#hikari.iterators.LazyIterator.enumerate"
>enumerate</a></code>
</p>
<p>Enumerate the paginated results lazily.</p>
<p>This behaves as an asyncio-friendly version of <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code>
which uses much less memory than collecting all the results first and
calling <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code> across them.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Optional int to start at. If omitted, this is <code>0</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for i, item in paginated_results.enumerate():
...    print(i, item)
(0, foo)
(1, bar)
(2, baz)
(3, bork)
(4, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
(12, bork)
(13, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9).limit(3):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, T]]</code></dt>
<dd>A paginated results view that asynchronously yields an increasing
counter in a tuple with each result, lazily.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.filter" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="filter" href="#hikari.iterators.LazyIterator.filter" id="hikari.iterators.BufferedLazyIterator.filter">filter</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="filter -- Filter the items by one or more conditions …" href="#hikari.iterators.LazyIterator.filter"
>filter</a></code>
</p>
<p>Filter the items by one or more conditions.</p>
<p>Each condition is treated as a predicate, being called with each item
that this iterator would return when it is requested.</p>
<p>All conditions must evaluate to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> for the item to be
returned. If this is not met, then the item is discarded and ignored,
the next matching item will be returned instead, if there is one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.filter(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that only emits values where all conditions are
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.flat_map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="flat_map" href="#hikari.iterators.LazyIterator.flat_map" id="hikari.iterators.BufferedLazyIterator.flat_map">flat_map</a>(
    flattener: _FlattenerT[<a href='#hikari.iterators.ValueT'>ValueT</a>, <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="flat_map -- Perform a flat mapping operation …" href="#hikari.iterators.LazyIterator.flat_map"
>flat_map</a></code>
</p>
<p>Perform a flat mapping operation.</p>
<p>This will pass each item in the iterator to the given <code><a href='https://docs.python.org/3/reference/compound_stmts.html#function'>function</a></code>
parameter, expecting a new <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code> or <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>
to be returned as the result. This means you can map to a new
<code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>,
async generator, or generator.</p>
<p>Remember that <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterator'>Iterator</a></code> implicitly provides <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>
compatibility.</p>
<p>This is used to provide lazy conversions, and can be used to implement
reactive-like pipelines if desired.</p>
<p>All results are combined into one large lazy iterator and yielded
lazily.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flattener</code></strong></dt>
<dd>A function that returns either an async iterator or iterator of
new values. Could be an attribute name instead.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following example generates a distinct collection of all mentioned
users in the given channel from the past 500 messages.</p>
<pre><code class="language-py">def iter_mentioned_users(message: hikari.Message) -&gt; typing.Iterable[Snowflake]:
    for match in re.findall(r&quot;&lt;@!?(\d+)&gt;&quot;, message.content):
        yield Snowflake(match)

mentioned_users = await (
    channel
    .history()
    .limit(500)
    .map(&quot;.content&quot;)
    .flat_map(iter_mentioned_users)
    .distinct()
)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.for_each" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="for_each" href="#hikari.iterators.LazyIterator.for_each" id="hikari.iterators.BufferedLazyIterator.for_each">for_each</a>(
    consumer: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="for_each -- Pass each value to a given consumer immediately." href="#hikari.iterators.LazyIterator.for_each"
>for_each</a></code>
</p>
<p>Pass each value to a given consumer immediately.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.last" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="last" href="#hikari.iterators.LazyIterator.last" id="hikari.iterators.BufferedLazyIterator.last">last</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="last -- Return the last element of this iterator only …" href="#hikari.iterators.LazyIterator.last"
>last</a></code>
</p>
<p>Return the last element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.ValueT'>ValueT</a></code></dt>
<dd>The last result.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This method will consume the whole iterator if run.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no result exists.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.limit" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="limit" href="#hikari.iterators.LazyIterator.limit" id="hikari.iterators.BufferedLazyIterator.limit">limit</a>(
    limit: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="limit -- Limit the number of items you receive from this async iterator …" href="#hikari.iterators.LazyIterator.limit"
>limit</a></code>
</p>
<p>Limit the number of items you receive from this async iterator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The number of items to get. This must be greater than zero.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for item in paginated_results.limit(3):
...     print(item)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>A paginated results view that asynchronously yields a maximum
of the given number of items before completing.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="map" href="#hikari.iterators.LazyIterator.map" id="hikari.iterators.BufferedLazyIterator.map">map</a>(
    transformation: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="map -- Map the values to a different value …" href="#hikari.iterators.LazyIterator.map"
>map</a></code>
</p>
<p>Map the values to a different value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformation</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The function to use to map the attribute. This may alternatively
be a string attribute name to replace the input value with. You
can provide nested attributes using the <code>.</code> operator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that maps each value to another value.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.next" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="next" href="#hikari.iterators.LazyIterator.next" id="hikari.iterators.BufferedLazyIterator.next">next</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="next -- Return the next element of this iterator only …" href="#hikari.iterators.LazyIterator.next"
>next</a></code>
</p>
<p>Return the next element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.ValueT'>ValueT</a></code></dt>
<dd>The next result.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no more results exist.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.reversed" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="reversed" href="#hikari.iterators.LazyIterator.reversed" id="hikari.iterators.BufferedLazyIterator.reversed">reversed</a>() -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="#hikari.iterators.LazyIterator.reversed"
>reversed</a></code>
</p>
<p>Return a lazy iterator of the remainder of this iterator's values reversed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>The lazy iterator of this iterator's remaining values reversed.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.skip" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip" href="#hikari.iterators.LazyIterator.skip" id="hikari.iterators.BufferedLazyIterator.skip">skip</a>(
    number: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip -- Drop the given number of items, then yield anything after …" href="#hikari.iterators.LazyIterator.skip"
>skip</a></code>
</p>
<p>Drop the given number of items, then yield anything after.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The max number of items to drop before any items are yielded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>A paginated results view that asynchronously yields all items
AFTER the given number of items are discarded first.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.skip_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_until" href="#hikari.iterators.LazyIterator.skip_until" id="hikari.iterators.BufferedLazyIterator.skip_until">skip_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip_until -- Discard items while all conditions are False …" href="#hikari.iterators.LazyIterator.skip_until"
>skip_until</a></code>
</p>
<p>Discard items while all conditions are False.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values once a condition has failed.
All items before this are discarded.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.skip_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_while" href="#hikari.iterators.LazyIterator.skip_while" id="hikari.iterators.BufferedLazyIterator.skip_while">skip_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip_while -- Discard items while all conditions are True …" href="#hikari.iterators.LazyIterator.skip_while"
>skip_while</a></code>
</p>
<p>Discard items while all conditions are True.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values once a condition has been met.
All items before this are discarded.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.sort" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="sort" href="#hikari.iterators.LazyIterator.sort" id="hikari.iterators.BufferedLazyIterator.sort">sort</a>(
    *,
    key: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a> = None,
    reverse: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> Sequence[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="sort -- Collect all results, then sort the collection before returning it." href="#hikari.iterators.LazyIterator.sort"
>sort</a></code>
</p>
<p>Collect all results, then sort the collection before returning it.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.take_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_until" href="#hikari.iterators.LazyIterator.take_until" id="hikari.iterators.BufferedLazyIterator.take_until">take_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="take_until -- Return each item until any conditions pass or the end is reached …" href="#hikari.iterators.LazyIterator.take_until"
>take_until</a></code>
</p>
<p>Return each item until any conditions pass or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values until any conditions are
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.BufferedLazyIterator.take_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_while" href="#hikari.iterators.LazyIterator.take_while" id="hikari.iterators.BufferedLazyIterator.take_while">take_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="take_while -- Return each item until any conditions fail or the end is reached …" href="#hikari.iterators.LazyIterator.take_while"
>take_while</a></code>
</p>
<p>Return each item until any conditions fail or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values until any conditions are not
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.iterators.FlatLazyIterator" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="FlatLazyIterator -- A lazy iterator that has all items in-memory and ready …" href="#hikari.iterators.FlatLazyIterator"
>FlatLazyIterator</a></h4>
</dt>
<dd>
<pre><code id="hikari.iterators.FlatLazyIterator" class="hljs python"><abbr title='A standard Python type.'>class</abbr> FlatLazyIterator (
    values: <a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>],
): ...</code></pre>
<p>A lazy iterator that has all items in-memory and ready.</p>
<p>This can be iterated across as a normal iterator, or as an async iterator.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L791-L812" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class FlatLazyIterator(typing.Generic[ValueT], LazyIterator[ValueT]):
    &#34;&#34;&#34;A lazy iterator that has all items in-memory and ready.

    This can be iterated across as a normal iterator, or as an async iterator.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_iter&#34;,)

    def __init__(self, values: typing.Iterable[ValueT]) -&gt; None:
        self._iter = iter(values)

    def __iter__(self) -&gt; FlatLazyIterator[ValueT]:
        return self

    def __next__(self) -&gt; ValueT:
        return next(self._iter)

    async def __anext__(self) -&gt; ValueT:
        try:
            return next(self._iter)
        except StopIteration:
            self._complete()</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="FlatLazyIterator -- A lazy iterator that has all items in-memory and ready …" href="#hikari.iterators.FlatLazyIterator"
>FlatLazyIterator</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></dt>
<dd class="nested"><p>A set of results that are fetched asynchronously from the API as needed …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.iterators.FlatLazyIterator.awaiting" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="awaiting" href="#hikari.iterators.LazyIterator.awaiting" id="hikari.iterators.FlatLazyIterator.awaiting">awaiting</a>(
    window_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 10,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="awaiting -- Await each item concurrently in a fixed size window …" href="#hikari.iterators.LazyIterator.awaiting"
>awaiting</a></code>
</p>
<p>Await each item concurrently in a fixed size window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>window_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The window size of how many tasks to await at once. You can set this
to <code>0</code> to await everything at once, but see the below warning.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Setting a large window size, or setting it to 0 to await everything
is a dangerous thing to do if you are making API calls. Some
endpoints will get ratelimited and cause a backup of waiting
tasks, others may begin to spam global rate limits instead
(the <code>fetch_user</code> endpoint seems to be notorious for doing this).</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call assumes that the iterator contains awaitable values as
input. MyPy cannot detect this nicely, so any cast is forced
internally.</p>
<p>If the item is not awaitable, you will receive a
<code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code> instead.</p>
<p>You have been warned. You cannot escape the ways of the duck type
young grasshopper.</p>
</div>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.chunk" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="chunk" href="#hikari.iterators.LazyIterator.chunk" id="hikari.iterators.FlatLazyIterator.chunk">chunk</a>(
    chunk_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="#hikari.iterators.LazyIterator.chunk"
>chunk</a></code>
</p>
<p>Return results in chunks of up to <code>chunk_size</code> amount of entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chunk_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The limit for how many results should be returned in each chunk.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that emits each chunked sequence.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.collect" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="collect" href="#hikari.iterators.LazyIterator.collect" id="hikari.iterators.FlatLazyIterator.collect">collect</a>(
    collector: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]], <a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]],
) -> Collection[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="collect -- Collect the results into a given type and return it …" href="#hikari.iterators.LazyIterator.collect"
>collect</a></code>
</p>
<p>Collect the results into a given type and return it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>collector</code></strong></dt>
<dd>A function that consumes a sequence of values and returns a
collection.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.count" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="count" href="#hikari.iterators.LazyIterator.count" id="hikari.iterators.FlatLazyIterator.count">count</a>() -> <a href='https://docs.python.org/3/library/functions.html#int'>int</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="count -- Count the number of results …" href="#hikari.iterators.LazyIterator.count"
>count</a></code>
</p>
<p>Count the number of results.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Number of results found.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.enumerate" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="enumerate" href="#hikari.iterators.LazyIterator.enumerate" id="hikari.iterators.FlatLazyIterator.enumerate">enumerate</a>(
    *,
    start: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, ~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="enumerate -- Enumerate the paginated results lazily …" href="#hikari.iterators.LazyIterator.enumerate"
>enumerate</a></code>
</p>
<p>Enumerate the paginated results lazily.</p>
<p>This behaves as an asyncio-friendly version of <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code>
which uses much less memory than collecting all the results first and
calling <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code> across them.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Optional int to start at. If omitted, this is <code>0</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for i, item in paginated_results.enumerate():
...    print(i, item)
(0, foo)
(1, bar)
(2, baz)
(3, bork)
(4, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
(12, bork)
(13, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9).limit(3):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, T]]</code></dt>
<dd>A paginated results view that asynchronously yields an increasing
counter in a tuple with each result, lazily.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.filter" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="filter" href="#hikari.iterators.LazyIterator.filter" id="hikari.iterators.FlatLazyIterator.filter">filter</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="filter -- Filter the items by one or more conditions …" href="#hikari.iterators.LazyIterator.filter"
>filter</a></code>
</p>
<p>Filter the items by one or more conditions.</p>
<p>Each condition is treated as a predicate, being called with each item
that this iterator would return when it is requested.</p>
<p>All conditions must evaluate to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> for the item to be
returned. If this is not met, then the item is discarded and ignored,
the next matching item will be returned instead, if there is one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.filter(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that only emits values where all conditions are
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.flat_map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="flat_map" href="#hikari.iterators.LazyIterator.flat_map" id="hikari.iterators.FlatLazyIterator.flat_map">flat_map</a>(
    flattener: _FlattenerT[<a href='#hikari.iterators.ValueT'>ValueT</a>, <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="flat_map -- Perform a flat mapping operation …" href="#hikari.iterators.LazyIterator.flat_map"
>flat_map</a></code>
</p>
<p>Perform a flat mapping operation.</p>
<p>This will pass each item in the iterator to the given <code><a href='https://docs.python.org/3/reference/compound_stmts.html#function'>function</a></code>
parameter, expecting a new <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code> or <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>
to be returned as the result. This means you can map to a new
<code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>,
async generator, or generator.</p>
<p>Remember that <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterator'>Iterator</a></code> implicitly provides <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>
compatibility.</p>
<p>This is used to provide lazy conversions, and can be used to implement
reactive-like pipelines if desired.</p>
<p>All results are combined into one large lazy iterator and yielded
lazily.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flattener</code></strong></dt>
<dd>A function that returns either an async iterator or iterator of
new values. Could be an attribute name instead.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following example generates a distinct collection of all mentioned
users in the given channel from the past 500 messages.</p>
<pre><code class="language-py">def iter_mentioned_users(message: hikari.Message) -&gt; typing.Iterable[Snowflake]:
    for match in re.findall(r&quot;&lt;@!?(\d+)&gt;&quot;, message.content):
        yield Snowflake(match)

mentioned_users = await (
    channel
    .history()
    .limit(500)
    .map(&quot;.content&quot;)
    .flat_map(iter_mentioned_users)
    .distinct()
)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.for_each" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="for_each" href="#hikari.iterators.LazyIterator.for_each" id="hikari.iterators.FlatLazyIterator.for_each">for_each</a>(
    consumer: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="for_each -- Pass each value to a given consumer immediately." href="#hikari.iterators.LazyIterator.for_each"
>for_each</a></code>
</p>
<p>Pass each value to a given consumer immediately.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.last" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="last" href="#hikari.iterators.LazyIterator.last" id="hikari.iterators.FlatLazyIterator.last">last</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="last -- Return the last element of this iterator only …" href="#hikari.iterators.LazyIterator.last"
>last</a></code>
</p>
<p>Return the last element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.ValueT'>ValueT</a></code></dt>
<dd>The last result.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This method will consume the whole iterator if run.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no result exists.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.limit" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="limit" href="#hikari.iterators.LazyIterator.limit" id="hikari.iterators.FlatLazyIterator.limit">limit</a>(
    limit: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="limit -- Limit the number of items you receive from this async iterator …" href="#hikari.iterators.LazyIterator.limit"
>limit</a></code>
</p>
<p>Limit the number of items you receive from this async iterator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The number of items to get. This must be greater than zero.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for item in paginated_results.limit(3):
...     print(item)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>A paginated results view that asynchronously yields a maximum
of the given number of items before completing.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="map" href="#hikari.iterators.LazyIterator.map" id="hikari.iterators.FlatLazyIterator.map">map</a>(
    transformation: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="map -- Map the values to a different value …" href="#hikari.iterators.LazyIterator.map"
>map</a></code>
</p>
<p>Map the values to a different value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformation</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The function to use to map the attribute. This may alternatively
be a string attribute name to replace the input value with. You
can provide nested attributes using the <code>.</code> operator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that maps each value to another value.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.next" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="next" href="#hikari.iterators.LazyIterator.next" id="hikari.iterators.FlatLazyIterator.next">next</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="next -- Return the next element of this iterator only …" href="#hikari.iterators.LazyIterator.next"
>next</a></code>
</p>
<p>Return the next element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.ValueT'>ValueT</a></code></dt>
<dd>The next result.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no more results exist.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.reversed" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="reversed" href="#hikari.iterators.LazyIterator.reversed" id="hikari.iterators.FlatLazyIterator.reversed">reversed</a>() -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="#hikari.iterators.LazyIterator.reversed"
>reversed</a></code>
</p>
<p>Return a lazy iterator of the remainder of this iterator's values reversed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>The lazy iterator of this iterator's remaining values reversed.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.skip" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip" href="#hikari.iterators.LazyIterator.skip" id="hikari.iterators.FlatLazyIterator.skip">skip</a>(
    number: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip -- Drop the given number of items, then yield anything after …" href="#hikari.iterators.LazyIterator.skip"
>skip</a></code>
</p>
<p>Drop the given number of items, then yield anything after.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The max number of items to drop before any items are yielded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>A paginated results view that asynchronously yields all items
AFTER the given number of items are discarded first.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.skip_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_until" href="#hikari.iterators.LazyIterator.skip_until" id="hikari.iterators.FlatLazyIterator.skip_until">skip_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip_until -- Discard items while all conditions are False …" href="#hikari.iterators.LazyIterator.skip_until"
>skip_until</a></code>
</p>
<p>Discard items while all conditions are False.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values once a condition has failed.
All items before this are discarded.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.skip_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_while" href="#hikari.iterators.LazyIterator.skip_while" id="hikari.iterators.FlatLazyIterator.skip_while">skip_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip_while -- Discard items while all conditions are True …" href="#hikari.iterators.LazyIterator.skip_while"
>skip_while</a></code>
</p>
<p>Discard items while all conditions are True.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values once a condition has been met.
All items before this are discarded.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.sort" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="sort" href="#hikari.iterators.LazyIterator.sort" id="hikari.iterators.FlatLazyIterator.sort">sort</a>(
    *,
    key: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a> = None,
    reverse: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> Sequence[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="sort -- Collect all results, then sort the collection before returning it." href="#hikari.iterators.LazyIterator.sort"
>sort</a></code>
</p>
<p>Collect all results, then sort the collection before returning it.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.take_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_until" href="#hikari.iterators.LazyIterator.take_until" id="hikari.iterators.FlatLazyIterator.take_until">take_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="take_until -- Return each item until any conditions pass or the end is reached …" href="#hikari.iterators.LazyIterator.take_until"
>take_until</a></code>
</p>
<p>Return each item until any conditions pass or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values until any conditions are
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.FlatLazyIterator.take_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_while" href="#hikari.iterators.LazyIterator.take_while" id="hikari.iterators.FlatLazyIterator.take_while">take_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="take_while -- Return each item until any conditions fail or the end is reached …" href="#hikari.iterators.LazyIterator.take_while"
>take_while</a></code>
</p>
<p>Return each item until any conditions fail or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values until any conditions are not
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.iterators.LazyIterator" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></h4>
</dt>
<dd>
<pre><code id="hikari.iterators.LazyIterator" class="hljs python"><abbr title='A standard Python type.'>class</abbr> LazyIterator (
    *args,
    **kwds,
): ...</code></pre>
<p>A set of results that are fetched asynchronously from the API as needed.</p>
<p>This is a <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterable'>AsyncIterable</a></code> and <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code> with several
additional helpful methods provided for convenience.</p>
<h2 id="examples">Examples</h2>
<p>You can use this in multiple ways.</p>
<p>As an async iterable:</p>
<pre><code class="language-py">&gt;&gt;&gt; async for item in paginated_results:
...    process(item)
</code></pre>
<p>As an eagerly retrieved set of results (performs all API calls at once,
which may be slow for large sets of data):</p>
<pre><code class="language-py">&gt;&gt;&gt; results = await paginated_results
&gt;&gt;&gt; # ... which is equivalent to this...
&gt;&gt;&gt; results = [item async for item in paginated_results]
</code></pre>
<p>As an async iterator (not recommended):</p>
<pre><code class="language-py">&gt;&gt;&gt; try:
...    while True:
...        process(await paginated_results.__anext__())
... except StopAsyncIteration:
...    pass
</code></pre>
<p>Additionally, you can make use of some of the provided helper methods
on this class to perform basic operations easily.</p>
<p>Iterating across the items with indexes (like <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code> for normal
iterables):</p>
<pre><code class="language-py">&gt;&gt;&gt; async for i, item in paginated_results.enumerate():
...    print(i, item)
(0, foo)
(1, bar)
(2, baz)
</code></pre>
<p>Limiting the number of results you iterate across:</p>
<pre><code class="language-py">&gt;&gt;&gt; async for item in paginated_results.limit(3):
...    process(item)
</code></pre>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L158-L719" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class LazyIterator(typing.Generic[ValueT], abc.ABC):
    &#34;&#34;&#34;A set of results that are fetched asynchronously from the API as needed.

    This is a `typing.AsyncIterable` and `typing.AsyncIterator` with several
    additional helpful methods provided for convenience.

    Examples
    --------
    You can use this in multiple ways.

    As an async iterable:

    ```py
    &gt;&gt;&gt; async for item in paginated_results:
    ...    process(item)
    ```

    As an eagerly retrieved set of results (performs all API calls at once,
    which may be slow for large sets of data):

    ```py
    &gt;&gt;&gt; results = await paginated_results
    &gt;&gt;&gt; # ... which is equivalent to this...
    &gt;&gt;&gt; results = [item async for item in paginated_results]
    ```

    As an async iterator (not recommended):

    ```py
    &gt;&gt;&gt; try:
    ...    while True:
    ...        process(await paginated_results.__anext__())
    ... except StopAsyncIteration:
    ...    pass
    ```

    Additionally, you can make use of some of the provided helper methods
    on this class to perform basic operations easily.

    Iterating across the items with indexes (like `builtins.enumerate` for normal
    iterables):

    ```py
    &gt;&gt;&gt; async for i, item in paginated_results.enumerate():
    ...    print(i, item)
    (0, foo)
    (1, bar)
    (2, baz)
    ```

    Limiting the number of results you iterate across:

    ```py
    &gt;&gt;&gt; async for item in paginated_results.limit(3):
    ...    process(item)
    ```
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def chunk(self, chunk_size: int) -&gt; LazyIterator[typing.Sequence[ValueT]]:
        &#34;&#34;&#34;Return results in chunks of up to `chunk_size` amount of entries.

        Parameters
        ----------
        chunk_size : int
            The limit for how many results should be returned in each chunk.

        Returns
        -------
        LazyIterator[typing.Sequence[ValueT]]
            `LazyIterator` that emits each chunked sequence.
        &#34;&#34;&#34;
        return _ChunkedLazyIterator(self, chunk_size)

    def map(
        self,
        transformation: typing.Union[typing.Callable[[ValueT], AnotherValueT], str],
    ) -&gt; LazyIterator[AnotherValueT]:
        &#34;&#34;&#34;Map the values to a different value.

        Parameters
        ----------
        transformation : typing.Union[typing.Callable[[ValueT], builtins.bool], builtins.str]
            The function to use to map the attribute. This may alternatively
            be a string attribute name to replace the input value with. You
            can provide nested attributes using the `.` operator.

        Returns
        -------
        LazyIterator[AnotherValueT]
            `LazyIterator` that maps each value to another value.
        &#34;&#34;&#34;
        if isinstance(transformation, str):
            transformation = typing.cast(&#34;spel.AttrGetter[ValueT, AnotherValueT]&#34;, spel.AttrGetter(transformation))

        return _MappingLazyIterator(self, transformation)

    async def for_each(self, consumer: typing.Callable[[ValueT], typing.Any]) -&gt; None:
        &#34;&#34;&#34;Pass each value to a given consumer immediately.&#34;&#34;&#34;
        if asyncio.iscoroutinefunction(consumer):
            async for item in self:
                await consumer(item)
        else:
            async for item in self:
                consumer(item)

    def filter(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Filter the items by one or more conditions.

        Each condition is treated as a predicate, being called with each item
        that this iterator would return when it is requested.

        All conditions must evaluate to `builtins.True` for the item to be
        returned. If this is not met, then the item is discarded and ignored,
        the next matching item will be returned instead, if there is one.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes
            are referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.filter((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            `LazyIterator` that only emits values where all conditions are
            matched.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;filter&#34;, *predicates, **attrs)
        return _FilteredLazyIterator(self, conditions)

    def take_while(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Return each item until any conditions fail or the end is reached.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes
            are referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.take_while((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            LazyIterator that only emits values until any conditions are not
            matched.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;take_while&#34;, *predicates, **attrs)
        return _TakeWhileLazyIterator(self, conditions)

    def take_until(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Return each item until any conditions pass or the end is reached.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes are
            referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.take_until((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            LazyIterator that only emits values until any conditions are
            matched.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;take_until&#34;, *predicates, **attrs)
        return _TakeWhileLazyIterator(self, ~conditions)

    def skip_while(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Discard items while all conditions are True.

        Items after this will be yielded as normal.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes
            are referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.skip_while((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            LazyIterator that only emits values once a condition has been met.
            All items before this are discarded.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;skip_while&#34;, *predicates, **attrs)
        return _DropWhileLazyIterator(self, conditions)

    def skip_until(
        self,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Discard items while all conditions are False.

        Items after this will be yielded as normal.

        Parameters
        ----------
        *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
            Predicates to invoke. These are functions that take a value and
            return `builtins.True` if it is of interest, or `builtins.False`
            otherwise. These may instead include 2-`builtins.tuple` objects
            consisting of a `builtins.str` attribute name (nested attributes are
            referred to using the `.` operator), and values to compare for
            equality. This allows you to specify conditions such as
            `members.skip_until((&#34;user.bot&#34;, True))`.
        **attrs : typing.Any
            Alternative to passing 2-tuples. Cannot specify nested attributes
            using this method.

        Returns
        -------
        LazyIterator[ValueT]
            LazyIterator that only emits values once a condition has failed.
            All items before this are discarded.
        &#34;&#34;&#34;
        conditions = self._map_predicates_and_attr_getters(&#34;skip_until&#34;, *predicates, **attrs)
        return _DropWhileLazyIterator(self, ~conditions)

    def enumerate(self, *, start: int = 0) -&gt; LazyIterator[typing.Tuple[int, ValueT]]:
        &#34;&#34;&#34;Enumerate the paginated results lazily.

        This behaves as an asyncio-friendly version of `builtins.enumerate`
        which uses much less memory than collecting all the results first and
        calling `builtins.enumerate` across them.

        Parameters
        ----------
        start : builtins.int
            Optional int to start at. If omitted, this is `0`.

        Examples
        --------
            &gt;&gt;&gt; async for i, item in paginated_results.enumerate():
            ...    print(i, item)
            (0, foo)
            (1, bar)
            (2, baz)
            (3, bork)
            (4, qux)

            &gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9):
            ...    print(i, item)
            (9, foo)
            (10, bar)
            (11, baz)
            (12, bork)
            (13, qux)

            &gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9).limit(3):
            ...    print(i, item)
            (9, foo)
            (10, bar)
            (11, baz)

        Returns
        -------
        LazyIterator[typing.Tuple[builtins.int, T]]
            A paginated results view that asynchronously yields an increasing
            counter in a tuple with each result, lazily.
        &#34;&#34;&#34;
        return _EnumeratedLazyIterator(self, start=start)

    def limit(self, limit: int) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Limit the number of items you receive from this async iterator.

        Parameters
        ----------
        limit : builtins.int
            The number of items to get. This must be greater than zero.

        Examples
        --------
            &gt;&gt;&gt; async for item in paginated_results.limit(3):
            ...     print(item)

        Returns
        -------
        LazyIterator[ValueT]
            A paginated results view that asynchronously yields a maximum
            of the given number of items before completing.
        &#34;&#34;&#34;
        return _LimitedLazyIterator(self, limit)

    def skip(self, number: int) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Drop the given number of items, then yield anything after.

        Parameters
        ----------
        number : builtins.int
            The max number of items to drop before any items are yielded.

        Returns
        -------
        LazyIterator[ValueT]
            A paginated results view that asynchronously yields all items
            AFTER the given number of items are discarded first.
        &#34;&#34;&#34;
        return _DropCountLazyIterator(self, number)

    async def next(self) -&gt; ValueT:
        &#34;&#34;&#34;Return the next element of this iterator only.

        Returns
        -------
        ValueT
            The next result.

        Raises
        ------
        builtins.LookupError
            If no more results exist.
        &#34;&#34;&#34;
        try:
            return await self.__anext__()
        except StopAsyncIteration:
            raise LookupError(&#34;No elements were found&#34;) from None

    async def last(self) -&gt; ValueT:
        &#34;&#34;&#34;Return the last element of this iterator only.

        Returns
        -------
        ValueT
            The last result.

        !!! note
            This method will consume the whole iterator if run.

        Raises
        ------
        builtins.LookupError
            If no result exists.
        &#34;&#34;&#34;
        return await self.reversed().next()

    def reversed(self) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Return a lazy iterator of the remainder of this iterator&#39;s values reversed.

        Returns
        -------
        LazyIterator[ValueT]
            The lazy iterator of this iterator&#39;s remaining values reversed.
        &#34;&#34;&#34;
        return _ReversedLazyIterator(self)

    async def sort(self, *, key: typing.Any = None, reverse: bool = False) -&gt; typing.Sequence[ValueT]:
        &#34;&#34;&#34;Collect all results, then sort the collection before returning it.&#34;&#34;&#34;
        return sorted(await self, key=key, reverse=reverse)

    async def collect(
        self, collector: typing.Callable[[typing.Sequence[ValueT]], typing.Collection[ValueT]]
    ) -&gt; typing.Collection[ValueT]:
        &#34;&#34;&#34;Collect the results into a given type and return it.

        Parameters
        ----------
        collector
            A function that consumes a sequence of values and returns a
            collection.
        &#34;&#34;&#34;
        return collector(await self)

    async def count(self) -&gt; int:
        &#34;&#34;&#34;Count the number of results.

        Returns
        -------
        builtins.int
            Number of results found.
        &#34;&#34;&#34;
        count = 0
        async for _ in self:
            count += 1

        return count

    def flat_map(self, flattener: _FlattenerT[ValueT, AnotherValueT]) -&gt; LazyIterator[AnotherValueT]:
        r&#34;&#34;&#34;Perform a flat mapping operation.

        This will pass each item in the iterator to the given `function`
        parameter, expecting a new `typing.Iterable` or `typing.AsyncIterator`
        to be returned as the result. This means you can map to a new
        `LazyIterator`, `typing.AsyncIterator`, `typing.Iterable`,
        async generator, or generator.

        Remember that `typing.Iterator` implicitly provides `typing.Iterable`
        compatibility.

        This is used to provide lazy conversions, and can be used to implement
        reactive-like pipelines if desired.

        All results are combined into one large lazy iterator and yielded
        lazily.

        Parameters
        ----------
        flattener
            A function that returns either an async iterator or iterator of
            new values. Could be an attribute name instead.

        Example
        -------

        The following example generates a distinct collection of all mentioned
        users in the given channel from the past 500 messages.

        ```py
        def iter_mentioned_users(message: hikari.Message) -&gt; typing.Iterable[Snowflake]:
            for match in re.findall(r&#34;&lt;@!?(\d+)&gt;&#34;, message.content):
                yield Snowflake(match)

        mentioned_users = await (
            channel
            .history()
            .limit(500)
            .map(&#34;.content&#34;)
            .flat_map(iter_mentioned_users)
            .distinct()
        )
        ```

        Returns
        -------
        LazyIterator[AnotherValueT]
            The new lazy iterator to return.
        &#34;&#34;&#34;
        return _FlatMapLazyIterator(self, flattener)

    def awaiting(self, window_size: int = 10) -&gt; LazyIterator[ValueT]:
        &#34;&#34;&#34;Await each item concurrently in a fixed size window.

        Parameters
        ----------
        window_size : int
            The window size of how many tasks to await at once. You can set this
            to `0` to await everything at once, but see the below warning.

        Returns
        -------
        LazyIterator[ValueT]
            The new lazy iterator to return.

        !!! warning
            Setting a large window size, or setting it to 0 to await everything
            is a dangerous thing to do if you are making API calls. Some
            endpoints will get ratelimited and cause a backup of waiting
            tasks, others may begin to spam global rate limits instead
            (the `fetch_user` endpoint seems to be notorious for doing this).

        !!! note
            This call assumes that the iterator contains awaitable values as
            input. MyPy cannot detect this nicely, so any cast is forced
            internally.

            If the item is not awaitable, you will receive a
            `builtins.TypeError` instead.

            You have been warned. You cannot escape the ways of the duck type
            young grasshopper.
        &#34;&#34;&#34;
        # Not type safe. Can I make this type safe?
        return _AwaitingLazyIterator(typing.cast(&#34;LazyIterator[typing.Awaitable[ValueT]]&#34;, self), window_size)

    @staticmethod
    def _map_predicates_and_attr_getters(
        alg_name: str,
        *predicates: typing.Union[str, typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
        **attrs: typing.Any,
    ) -&gt; All[ValueT]:
        if not predicates and not attrs:
            raise TypeError(f&#34;You should provide at least one predicate to {alg_name}()&#34;)

        conditions: typing.List[typing.Callable[[ValueT], bool]] = []

        for p in predicates:
            if isinstance(p, tuple):
                name, value = p
                tuple_comparator: AttrComparator[ValueT] = AttrComparator(name, value)
                conditions.append(tuple_comparator)
            elif isinstance(p, str):
                comparator: AttrComparator[ValueT] = AttrComparator(p, True, bool)
                conditions.append(comparator)
            else:
                conditions.append(p)

        for name, value in attrs.items():
            attr_comparator: AttrComparator[ValueT] = AttrComparator(name, value)
            conditions.append(attr_comparator)

        return All(conditions)

    def _complete(self) -&gt; typing.NoReturn:
        raise StopAsyncIteration(&#34;No more items exist in this iterator. It has been exhausted.&#34;) from None

    def __aiter__(self) -&gt; LazyIterator[ValueT]:
        # We are our own async iterator.
        return self

    def __iter__(self) -&gt; LazyIterator[ValueT]:
        # This iterator is async only.
        cls = type(self)
        raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is an async-only iterator, did you mean &#39;async for&#39;?&#34;)

    async def _fetch_all(self) -&gt; typing.Sequence[ValueT]:
        return [item async for item in self]

    def __await__(self) -&gt; typing.Generator[None, None, typing.Sequence[ValueT]]:
        return self._fetch_all().__await__()

    @abc.abstractmethod
    async def __anext__(self) -&gt; ValueT:
        ...</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- A base abstract class for all event streamers …" href="api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></dt>
<dd class="nested"><p>A base abstract class for all event streamers …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="BufferedLazyIterator -- A special kind of lazy iterator that is used by internal components …" href="#hikari.iterators.BufferedLazyIterator"
>BufferedLazyIterator</a></dt>
<dd class="nested"><p>A special kind of lazy iterator that is used by internal components …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="FlatLazyIterator -- A lazy iterator that has all items in-memory and ready …" href="#hikari.iterators.FlatLazyIterator"
>FlatLazyIterator</a></dt>
<dd class="nested"><p>A lazy iterator that has all items in-memory and ready …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="#hikari.iterators.LazyIterator"
>LazyIterator</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.iterators.LazyIterator.awaiting" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="awaiting" href="#hikari.iterators.LazyIterator.awaiting" id="hikari.iterators.LazyIterator.awaiting">awaiting</a>(
    window_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 10,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Await each item concurrently in a fixed size window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>window_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The window size of how many tasks to await at once. You can set this
to <code>0</code> to await everything at once, but see the below warning.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Setting a large window size, or setting it to 0 to await everything
is a dangerous thing to do if you are making API calls. Some
endpoints will get ratelimited and cause a backup of waiting
tasks, others may begin to spam global rate limits instead
(the <code>fetch_user</code> endpoint seems to be notorious for doing this).</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call assumes that the iterator contains awaitable values as
input. MyPy cannot detect this nicely, so any cast is forced
internally.</p>
<p>If the item is not awaitable, you will receive a
<code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code> instead.</p>
<p>You have been warned. You cannot escape the ways of the duck type
young grasshopper.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L636-L669" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def awaiting(self, window_size: int = 10) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Await each item concurrently in a fixed size window.

    Parameters
    ----------
    window_size : int
        The window size of how many tasks to await at once. You can set this
        to `0` to await everything at once, but see the below warning.

    Returns
    -------
    LazyIterator[ValueT]
        The new lazy iterator to return.

    !!! warning
        Setting a large window size, or setting it to 0 to await everything
        is a dangerous thing to do if you are making API calls. Some
        endpoints will get ratelimited and cause a backup of waiting
        tasks, others may begin to spam global rate limits instead
        (the `fetch_user` endpoint seems to be notorious for doing this).

    !!! note
        This call assumes that the iterator contains awaitable values as
        input. MyPy cannot detect this nicely, so any cast is forced
        internally.

        If the item is not awaitable, you will receive a
        `builtins.TypeError` instead.

        You have been warned. You cannot escape the ways of the duck type
        young grasshopper.
    &#34;&#34;&#34;
    # Not type safe. Can I make this type safe?
    return _AwaitingLazyIterator(typing.cast(&#34;LazyIterator[typing.Awaitable[ValueT]]&#34;, self), window_size)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.chunk" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="chunk" href="#hikari.iterators.LazyIterator.chunk" id="hikari.iterators.LazyIterator.chunk">chunk</a>(
    chunk_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p>Return results in chunks of up to <code>chunk_size</code> amount of entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chunk_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The limit for how many results should be returned in each chunk.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that emits each chunked sequence.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L218-L231" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def chunk(self, chunk_size: int) -&gt; LazyIterator[typing.Sequence[ValueT]]:
    &#34;&#34;&#34;Return results in chunks of up to `chunk_size` amount of entries.

    Parameters
    ----------
    chunk_size : int
        The limit for how many results should be returned in each chunk.

    Returns
    -------
    LazyIterator[typing.Sequence[ValueT]]
        `LazyIterator` that emits each chunked sequence.
    &#34;&#34;&#34;
    return _ChunkedLazyIterator(self, chunk_size)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.collect" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="collect" href="#hikari.iterators.LazyIterator.collect" id="hikari.iterators.LazyIterator.collect">collect</a>(
    collector: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]], <a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]],
) -> Collection[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Collect the results into a given type and return it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>collector</code></strong></dt>
<dd>A function that consumes a sequence of values and returns a
collection.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L557-L568" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def collect(
    self, collector: typing.Callable[[typing.Sequence[ValueT]], typing.Collection[ValueT]]
) -&gt; typing.Collection[ValueT]:
    &#34;&#34;&#34;Collect the results into a given type and return it.

    Parameters
    ----------
    collector
        A function that consumes a sequence of values and returns a
        collection.
    &#34;&#34;&#34;
    return collector(await self)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.count" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="count" href="#hikari.iterators.LazyIterator.count" id="hikari.iterators.LazyIterator.count">count</a>() -> <a href='https://docs.python.org/3/library/functions.html#int'>int</a>: ...</code></pre>
</dt>
<dd>
<p>Count the number of results.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Number of results found.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L570-L582" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def count(self) -&gt; int:
    &#34;&#34;&#34;Count the number of results.

    Returns
    -------
    builtins.int
        Number of results found.
    &#34;&#34;&#34;
    count = 0
    async for _ in self:
        count += 1

    return count</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.enumerate" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="enumerate" href="#hikari.iterators.LazyIterator.enumerate" id="hikari.iterators.LazyIterator.enumerate">enumerate</a>(
    *,
    start: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, ~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p>Enumerate the paginated results lazily.</p>
<p>This behaves as an asyncio-friendly version of <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code>
which uses much less memory than collecting all the results first and
calling <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code> across them.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Optional int to start at. If omitted, this is <code>0</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for i, item in paginated_results.enumerate():
...    print(i, item)
(0, foo)
(1, bar)
(2, baz)
(3, bork)
(4, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
(12, bork)
(13, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9).limit(3):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, T]]</code></dt>
<dd>A paginated results view that asynchronously yields an increasing
counter in a tuple with each result, lazily.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L426-L468" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def enumerate(self, *, start: int = 0) -&gt; LazyIterator[typing.Tuple[int, ValueT]]:
    &#34;&#34;&#34;Enumerate the paginated results lazily.

    This behaves as an asyncio-friendly version of `builtins.enumerate`
    which uses much less memory than collecting all the results first and
    calling `builtins.enumerate` across them.

    Parameters
    ----------
    start : builtins.int
        Optional int to start at. If omitted, this is `0`.

    Examples
    --------
        &gt;&gt;&gt; async for i, item in paginated_results.enumerate():
        ...    print(i, item)
        (0, foo)
        (1, bar)
        (2, baz)
        (3, bork)
        (4, qux)

        &gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9):
        ...    print(i, item)
        (9, foo)
        (10, bar)
        (11, baz)
        (12, bork)
        (13, qux)

        &gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9).limit(3):
        ...    print(i, item)
        (9, foo)
        (10, bar)
        (11, baz)

    Returns
    -------
    LazyIterator[typing.Tuple[builtins.int, T]]
        A paginated results view that asynchronously yields an increasing
        counter in a tuple with each result, lazily.
    &#34;&#34;&#34;
    return _EnumeratedLazyIterator(self, start=start)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.filter" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="filter" href="#hikari.iterators.LazyIterator.filter" id="hikari.iterators.LazyIterator.filter">filter</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Filter the items by one or more conditions.</p>
<p>Each condition is treated as a predicate, being called with each item
that this iterator would return when it is requested.</p>
<p>All conditions must evaluate to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> for the item to be
returned. If this is not met, then the item is discarded and ignored,
the next matching item will be returned instead, if there is one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.filter(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that only emits values where all conditions are
matched.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L265-L300" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def filter(
    self,
    *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
    **attrs: typing.Any,
) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Filter the items by one or more conditions.

    Each condition is treated as a predicate, being called with each item
    that this iterator would return when it is requested.

    All conditions must evaluate to `builtins.True` for the item to be
    returned. If this is not met, then the item is discarded and ignored,
    the next matching item will be returned instead, if there is one.

    Parameters
    ----------
    *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
        Predicates to invoke. These are functions that take a value and
        return `builtins.True` if it is of interest, or `builtins.False`
        otherwise. These may instead include 2-`builtins.tuple` objects
        consisting of a `builtins.str` attribute name (nested attributes
        are referred to using the `.` operator), and values to compare for
        equality. This allows you to specify conditions such as
        `members.filter((&#34;user.bot&#34;, True))`.
    **attrs : typing.Any
        Alternative to passing 2-tuples. Cannot specify nested attributes
        using this method.

    Returns
    -------
    LazyIterator[ValueT]
        `LazyIterator` that only emits values where all conditions are
        matched.
    &#34;&#34;&#34;
    conditions = self._map_predicates_and_attr_getters(&#34;filter&#34;, *predicates, **attrs)
    return _FilteredLazyIterator(self, conditions)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.flat_map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="flat_map" href="#hikari.iterators.LazyIterator.flat_map" id="hikari.iterators.LazyIterator.flat_map">flat_map</a>(
    flattener: _FlattenerT[<a href='#hikari.iterators.ValueT'>ValueT</a>, <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Perform a flat mapping operation.</p>
<p>This will pass each item in the iterator to the given <code><a href='https://docs.python.org/3/reference/compound_stmts.html#function'>function</a></code>
parameter, expecting a new <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code> or <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>
to be returned as the result. This means you can map to a new
<code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>,
async generator, or generator.</p>
<p>Remember that <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterator'>Iterator</a></code> implicitly provides <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>
compatibility.</p>
<p>This is used to provide lazy conversions, and can be used to implement
reactive-like pipelines if desired.</p>
<p>All results are combined into one large lazy iterator and yielded
lazily.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flattener</code></strong></dt>
<dd>A function that returns either an async iterator or iterator of
new values. Could be an attribute name instead.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following example generates a distinct collection of all mentioned
users in the given channel from the past 500 messages.</p>
<pre><code class="language-py">def iter_mentioned_users(message: hikari.Message) -&gt; typing.Iterable[Snowflake]:
    for match in re.findall(r&quot;&lt;@!?(\d+)&gt;&quot;, message.content):
        yield Snowflake(match)

mentioned_users = await (
    channel
    .history()
    .limit(500)
    .map(&quot;.content&quot;)
    .flat_map(iter_mentioned_users)
    .distinct()
)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L584-L634" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def flat_map(self, flattener: _FlattenerT[ValueT, AnotherValueT]) -&gt; LazyIterator[AnotherValueT]:
    r&#34;&#34;&#34;Perform a flat mapping operation.

    This will pass each item in the iterator to the given `function`
    parameter, expecting a new `typing.Iterable` or `typing.AsyncIterator`
    to be returned as the result. This means you can map to a new
    `LazyIterator`, `typing.AsyncIterator`, `typing.Iterable`,
    async generator, or generator.

    Remember that `typing.Iterator` implicitly provides `typing.Iterable`
    compatibility.

    This is used to provide lazy conversions, and can be used to implement
    reactive-like pipelines if desired.

    All results are combined into one large lazy iterator and yielded
    lazily.

    Parameters
    ----------
    flattener
        A function that returns either an async iterator or iterator of
        new values. Could be an attribute name instead.

    Example
    -------

    The following example generates a distinct collection of all mentioned
    users in the given channel from the past 500 messages.

    ```py
    def iter_mentioned_users(message: hikari.Message) -&gt; typing.Iterable[Snowflake]:
        for match in re.findall(r&#34;&lt;@!?(\d+)&gt;&#34;, message.content):
            yield Snowflake(match)

    mentioned_users = await (
        channel
        .history()
        .limit(500)
        .map(&#34;.content&#34;)
        .flat_map(iter_mentioned_users)
        .distinct()
    )
    ```

    Returns
    -------
    LazyIterator[AnotherValueT]
        The new lazy iterator to return.
    &#34;&#34;&#34;
    return _FlatMapLazyIterator(self, flattener)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.for_each" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="for_each" href="#hikari.iterators.LazyIterator.for_each" id="hikari.iterators.LazyIterator.for_each">for_each</a>(
    consumer: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Pass each value to a given consumer immediately.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L256-L263" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def for_each(self, consumer: typing.Callable[[ValueT], typing.Any]) -&gt; None:
    &#34;&#34;&#34;Pass each value to a given consumer immediately.&#34;&#34;&#34;
    if asyncio.iscoroutinefunction(consumer):
        async for item in self:
            await consumer(item)
    else:
        async for item in self:
            consumer(item)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.last" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="last" href="#hikari.iterators.LazyIterator.last" id="hikari.iterators.LazyIterator.last">last</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p>Return the last element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.ValueT'>ValueT</a></code></dt>
<dd>The last result.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This method will consume the whole iterator if run.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no result exists.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L525-L541" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def last(self) -&gt; ValueT:
    &#34;&#34;&#34;Return the last element of this iterator only.

    Returns
    -------
    ValueT
        The last result.

    !!! note
        This method will consume the whole iterator if run.

    Raises
    ------
    builtins.LookupError
        If no result exists.
    &#34;&#34;&#34;
    return await self.reversed().next()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.limit" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="limit" href="#hikari.iterators.LazyIterator.limit" id="hikari.iterators.LazyIterator.limit">limit</a>(
    limit: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Limit the number of items you receive from this async iterator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The number of items to get. This must be greater than zero.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for item in paginated_results.limit(3):
...     print(item)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>A paginated results view that asynchronously yields a maximum
of the given number of items before completing.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L470-L489" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def limit(self, limit: int) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Limit the number of items you receive from this async iterator.

    Parameters
    ----------
    limit : builtins.int
        The number of items to get. This must be greater than zero.

    Examples
    --------
        &gt;&gt;&gt; async for item in paginated_results.limit(3):
        ...     print(item)

    Returns
    -------
    LazyIterator[ValueT]
        A paginated results view that asynchronously yields a maximum
        of the given number of items before completing.
    &#34;&#34;&#34;
    return _LimitedLazyIterator(self, limit)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="map" href="#hikari.iterators.LazyIterator.map" id="hikari.iterators.LazyIterator.map">map</a>(
    transformation: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Map the values to a different value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformation</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The function to use to map the attribute. This may alternatively
be a string attribute name to replace the input value with. You
can provide nested attributes using the <code>.</code> operator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]</code></dt>
<dd><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a></code> that maps each value to another value.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L233-L254" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def map(
    self,
    transformation: typing.Union[typing.Callable[[ValueT], AnotherValueT], str],
) -&gt; LazyIterator[AnotherValueT]:
    &#34;&#34;&#34;Map the values to a different value.

    Parameters
    ----------
    transformation : typing.Union[typing.Callable[[ValueT], builtins.bool], builtins.str]
        The function to use to map the attribute. This may alternatively
        be a string attribute name to replace the input value with. You
        can provide nested attributes using the `.` operator.

    Returns
    -------
    LazyIterator[AnotherValueT]
        `LazyIterator` that maps each value to another value.
    &#34;&#34;&#34;
    if isinstance(transformation, str):
        transformation = typing.cast(&#34;spel.AttrGetter[ValueT, AnotherValueT]&#34;, spel.AttrGetter(transformation))

    return _MappingLazyIterator(self, transformation)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.next" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="next" href="#hikari.iterators.LazyIterator.next" id="hikari.iterators.LazyIterator.next">next</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p>Return the next element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.ValueT'>ValueT</a></code></dt>
<dd>The next result.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no more results exist.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L507-L523" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def next(self) -&gt; ValueT:
    &#34;&#34;&#34;Return the next element of this iterator only.

    Returns
    -------
    ValueT
        The next result.

    Raises
    ------
    builtins.LookupError
        If no more results exist.
    &#34;&#34;&#34;
    try:
        return await self.__anext__()
    except StopAsyncIteration:
        raise LookupError(&#34;No elements were found&#34;) from None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.reversed" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="reversed" href="#hikari.iterators.LazyIterator.reversed" id="hikari.iterators.LazyIterator.reversed">reversed</a>() -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Return a lazy iterator of the remainder of this iterator's values reversed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>The lazy iterator of this iterator's remaining values reversed.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L543-L551" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def reversed(self) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Return a lazy iterator of the remainder of this iterator&#39;s values reversed.

    Returns
    -------
    LazyIterator[ValueT]
        The lazy iterator of this iterator&#39;s remaining values reversed.
    &#34;&#34;&#34;
    return _ReversedLazyIterator(self)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.skip" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip" href="#hikari.iterators.LazyIterator.skip" id="hikari.iterators.LazyIterator.skip">skip</a>(
    number: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Drop the given number of items, then yield anything after.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The max number of items to drop before any items are yielded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>A paginated results view that asynchronously yields all items
AFTER the given number of items are discarded first.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L491-L505" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def skip(self, number: int) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Drop the given number of items, then yield anything after.

    Parameters
    ----------
    number : builtins.int
        The max number of items to drop before any items are yielded.

    Returns
    -------
    LazyIterator[ValueT]
        A paginated results view that asynchronously yields all items
        AFTER the given number of items are discarded first.
    &#34;&#34;&#34;
    return _DropCountLazyIterator(self, number)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.skip_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_until" href="#hikari.iterators.LazyIterator.skip_until" id="hikari.iterators.LazyIterator.skip_until">skip_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Discard items while all conditions are False.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values once a condition has failed.
All items before this are discarded.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L394-L424" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def skip_until(
    self,
    *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
    **attrs: typing.Any,
) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Discard items while all conditions are False.

    Items after this will be yielded as normal.

    Parameters
    ----------
    *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
        Predicates to invoke. These are functions that take a value and
        return `builtins.True` if it is of interest, or `builtins.False`
        otherwise. These may instead include 2-`builtins.tuple` objects
        consisting of a `builtins.str` attribute name (nested attributes are
        referred to using the `.` operator), and values to compare for
        equality. This allows you to specify conditions such as
        `members.skip_until((&#34;user.bot&#34;, True))`.
    **attrs : typing.Any
        Alternative to passing 2-tuples. Cannot specify nested attributes
        using this method.

    Returns
    -------
    LazyIterator[ValueT]
        LazyIterator that only emits values once a condition has failed.
        All items before this are discarded.
    &#34;&#34;&#34;
    conditions = self._map_predicates_and_attr_getters(&#34;skip_until&#34;, *predicates, **attrs)
    return _DropWhileLazyIterator(self, ~conditions)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.skip_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_while" href="#hikari.iterators.LazyIterator.skip_while" id="hikari.iterators.LazyIterator.skip_while">skip_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Discard items while all conditions are True.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values once a condition has been met.
All items before this are discarded.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L362-L392" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def skip_while(
    self,
    *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
    **attrs: typing.Any,
) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Discard items while all conditions are True.

    Items after this will be yielded as normal.

    Parameters
    ----------
    *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
        Predicates to invoke. These are functions that take a value and
        return `builtins.True` if it is of interest, or `builtins.False`
        otherwise. These may instead include 2-`builtins.tuple` objects
        consisting of a `builtins.str` attribute name (nested attributes
        are referred to using the `.` operator), and values to compare for
        equality. This allows you to specify conditions such as
        `members.skip_while((&#34;user.bot&#34;, True))`.
    **attrs : typing.Any
        Alternative to passing 2-tuples. Cannot specify nested attributes
        using this method.

    Returns
    -------
    LazyIterator[ValueT]
        LazyIterator that only emits values once a condition has been met.
        All items before this are discarded.
    &#34;&#34;&#34;
    conditions = self._map_predicates_and_attr_getters(&#34;skip_while&#34;, *predicates, **attrs)
    return _DropWhileLazyIterator(self, conditions)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.sort" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="sort" href="#hikari.iterators.LazyIterator.sort" id="hikari.iterators.LazyIterator.sort">sort</a>(
    *,
    key: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a> = None,
    reverse: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> Sequence[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Collect all results, then sort the collection before returning it.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L553-L555" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def sort(self, *, key: typing.Any = None, reverse: bool = False) -&gt; typing.Sequence[ValueT]:
    &#34;&#34;&#34;Collect all results, then sort the collection before returning it.&#34;&#34;&#34;
    return sorted(await self, key=key, reverse=reverse)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.take_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_until" href="#hikari.iterators.LazyIterator.take_until" id="hikari.iterators.LazyIterator.take_until">take_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Return each item until any conditions pass or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values until any conditions are
matched.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L332-L360" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def take_until(
    self,
    *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
    **attrs: typing.Any,
) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Return each item until any conditions pass or the end is reached.

    Parameters
    ----------
    *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
        Predicates to invoke. These are functions that take a value and
        return `builtins.True` if it is of interest, or `builtins.False`
        otherwise. These may instead include 2-`builtins.tuple` objects
        consisting of a `builtins.str` attribute name (nested attributes are
        referred to using the `.` operator), and values to compare for
        equality. This allows you to specify conditions such as
        `members.take_until((&#34;user.bot&#34;, True))`.
    **attrs : typing.Any
        Alternative to passing 2-tuples. Cannot specify nested attributes
        using this method.

    Returns
    -------
    LazyIterator[ValueT]
        LazyIterator that only emits values until any conditions are
        matched.
    &#34;&#34;&#34;
    conditions = self._map_predicates_and_attr_getters(&#34;take_until&#34;, *predicates, **attrs)
    return _TakeWhileLazyIterator(self, ~conditions)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.iterators.LazyIterator.take_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_while" href="#hikari.iterators.LazyIterator.take_while" id="hikari.iterators.LazyIterator.take_while">take_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p>Return each item until any conditions fail or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]</code></dt>
<dd>LazyIterator that only emits values until any conditions are not
matched.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/iterators.py#L302-L330" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def take_while(
    self,
    *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[ValueT], bool]],
    **attrs: typing.Any,
) -&gt; LazyIterator[ValueT]:
    &#34;&#34;&#34;Return each item until any conditions fail or the end is reached.

    Parameters
    ----------
    *predicates : typing.Union[typing.Callable[[ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any]]
        Predicates to invoke. These are functions that take a value and
        return `builtins.True` if it is of interest, or `builtins.False`
        otherwise. These may instead include 2-`builtins.tuple` objects
        consisting of a `builtins.str` attribute name (nested attributes
        are referred to using the `.` operator), and values to compare for
        equality. This allows you to specify conditions such as
        `members.take_while((&#34;user.bot&#34;, True))`.
    **attrs : typing.Any
        Alternative to passing 2-tuples. Cannot specify nested attributes
        using this method.

    Returns
    -------
    LazyIterator[ValueT]
        LazyIterator that only emits values until any conditions are not
        matched.
    &#34;&#34;&#34;
    conditions = self._map_predicates_and_attr_getters(&#34;take_while&#34;, *predicates, **attrs)
    return _TakeWhileLazyIterator(self, conditions)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>